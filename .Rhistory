coactive_bass(mod1, mod2)
document()
coactive_bass(mod1, mod2)
diag(C12)
eigen(V12)
V12
V
C = V
eigen(V)
C
C1 = C_bass(mod1)
C2 = C_bass(mod2)
C12 = Cfg_bass(mod1, mod2)
V12 = (C12 + t(C12))/2
V12
sum(diag(V12))
sum(eigen(V12)$values)
diag(C12)
eigen(V12)$values
document()
coactive_bass(mod1, mod2)
library(concordance)
CONC
dim(CONC)
document()
library(concordance)
document()
library(concordance)
choose(140, 2)
plot(mod)
plot(mod[[1]])
document()
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.8)
Cmc <- C_mc(f, measure, nmc=1e5)
library(concordance)
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.8)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, 0.8), nrow=N, ncol=p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
Cbass <- C_bass(mod_bass, prior=pr)
Cmc
Cbass
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.1)
Cmc <- C_mc(f, measure, nmc=1e5)
#X <- matrix(rnorm(N*p, 0.5, 0.1), nrow=N, ncol=p)
X <- randomLHS(N, p)
library(lhs)
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.1)
Cmc <- C_mc(f, measure, nmc=1e5)
#X <- matrix(rnorm(N*p, 0.5, 0.1), nrow=N, ncol=p)
X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
Cbass <- C_bass(mod_bass, prior=pr)
Cmc
Cbass
Cbass - Cmc
X <- matrix(rnorm(N*p, 0.5, 0.1), nrow=N, ncol=p)
#X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.1, weights=1)
Cbass <- C_bass(mod_bass, prior=pr)
Cbass - Cmc
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.8)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, 0.8), nrow=N, ncol=p)
#X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
Cbass <- C_bass(mod_bass, prior=pr)
Cmc
Cbass
Cmc - Cbass
mod <-  mod_bass
prior = pr
i = 1
prior[[i]]
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- scale_range(prior[[i]]$trunc, mod$range.des[,i])
scale_range <- function(x, r=NULL){
if (is.null(r))
r <- range(x)
if ((r[2] - r[1]) == 0)
return(x - r[1])
return((x - r[1])/(r[2] - r[1]))
}
prior[[i]]$trunc <- scale_range(prior[[i]]$trunc, mod$range.des[,i])
prior[[i]]
# 2. Handle each distribution type separately
distribution = prior[[i]]$dist
distribution == "normal"
is.null(prior[[i]]$weights)
scale_range(prior[[i]]$mean, mod$range.des[,i])
mod$range.des[,i]
prior[[i]]$mean
plot(NULL, ylim=c(0, 1), xlim=c(mod$range.des[,i]))
abline(v=mod$range.des[,i], lty=3, col='red')
abline(v=0.5)
(0.5 + 1.600383)/(2.76+1.6)
prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$sd
pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
#HANDLE PRIORS
for(i in 1:(mod$pdes)){
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- scale_range(prior[[i]]$trunc, mod$range.des[,i])
# 2. Handle each distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- scale_range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc
# DF: prior[[i]]$z
# change weights with truncation
# divide by cc instead to keep the same prior shape
# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.001, 0.999), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "uniform"){
prior[[i]]$weights = 1
#Check for extrapolation
if(((prior[[i]]$trunc[1] < 0 - 0.1) | (prior[[i]]$trunc[2] > 1 + 0.1))){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "beta"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01 | abs(max(mod$xx.des[,i]) - 1) > 0.01){
warning("For dist=\"beta\", data should be scaled to (0, 1) range BEFORE fitting bass model")
}
}
if(distribution == "gamma"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01){
warning("For dist=\"gamma\", data should be shifted to have a minimum of 0 BEFORE fitting bass model")
}
prior[[i]]$rate = prior[[i]]$rate * prior[[i]]$trunc[2]
}
}
prior
mod$range.des
mod$xx.des
apply(mod$xx.des, 1, range
)
apply(mod$xx.des, 2, range)
Xt <- mod$xx.des
# Get transformation matrix
A_tform <- diag(1/apply(mod$range.des, 2, diff))
A_tform
scale_range
range(0.5)
#Check for extrapolation
qq <- qnorm(c(0.001, 0.999), prior[[i]]$mean, prior[[i]]$sd)
qq
A_tform
apply(mod$range.des, 2, diff)
A_tform
scaled
document()
library(devtools)
document()
test_that("simple polynomial example with Gaussian measure", {
cat('simple polynomial example test with Gaussian measure')
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.8)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, 0.8), nrow=N, ncol=p)
#X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
?C_bass
}
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, 0.8)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, 0.8), nrow=N, ncol=p)
#X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=0.8, weights=1)
Cbass <- C_bass(mod_bass, prior=pr, scale01=TRUE)
Cbass
Cmc
A_tform <- diag(1/apply(mod_bass$range.des, 2, diff))
A_tform
A%*%Cbass%*%A
A_tform%*%Cbass%*%A_tform
# Sim Study Parameters
N <- 1000
p <- 3
sd0 <- 0.05
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, sd0)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, sd0), nrow=N, ncol=p)
X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
# Sim Study Parameters
N <- 5000
p <- 3
sd0 <- 0.05
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, 0.5, sd0)
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, 0.5, sd0), nrow=N, ncol=p)
X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=sd0, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=sd0, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0.5, sd=sd0, weights=1)
Cbass <- C_bass(mod_bass, prior=pr, scale01=TRUE)
Cbass
Cmc
sd0
mod <- mod_bass
prior = pr
prior[[i]]$trunc <- scale_range(prior[[i]]$trunc, mod$range.des[,i])
prior[[i]]
i
# 2. Handle each distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- scale_range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc
# DF: prior[[i]]$z
# change weights with truncation
# divide by cc instead to keep the same prior shape
# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.001, 0.999), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
prior[[io]]
prior[[i]]
X <- matrix(rnorm(N*p, c(5, 10, 15), c(1, 2, 5)), nrow=N, ncol=p)
X
range(X[,1])
range(X[,2])
range(X[,3])
X <- matrix(rnorm(N*p, c(5, 10, 15), c(1, 2, 5)), nrow=N, ncol=p, byrow=TRUE)
range(X[,2])
range(X[,1])
range(X[,3])
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 5000
p <- 3
# Get true value of C matrix (with monte carlo)
measure <- function() rnorm(p, c(5, 10, 15), c(1, 2, 5))
Cmc <- C_mc(f, measure, nmc=1e5)
X <- matrix(rnorm(N*p, c(5, 10, 15), c(1, 2, 5)), nrow=N, ncol=p, byrow=TRUE)
#X <- randomLHS(N, p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
pr <- list()
pr[[1]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=5,  sd=1, weights=1)
pr[[2]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=10, sd=2, weights=1)
pr[[3]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=15, sd=5, weights=1)
Cbass <- C_bass(mod_bass, prior=pr, scale01=TRUE)
Cbass
Cmc
Cbass <- C_bass(mod_bass, prior=pr)
Cbass
CmcCmc - Cbass
Cmc - Cbass
(Cmc - Cbass)/Cmc
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (with monte carlo)
mu <- rep(0.5, 3)
Sigma <- matrix(c(1, 0.5, -0.2,
0.5, 1, 0.1,
-0.2, 0.1, 1),
ncol=3, byrow=TRUE)/3
measure <- function() as.numeric(mvtnorm::rmvnorm(1, mu, Sigma))
Cmc <- C_mc(f, measure, nmc=5e4)
# Get estimate of C matrix (with C_bass)
X <- mvtnorm::rmvnorm(N, mu, Sigma)
Yf <- apply(X, 1, f)
Esig <- eigen(Sigma)
A <- Esig$vectors%*%diag(1/sqrt(Esig$values))%*%t(Esig$vectors)
X0 <- X - rep(mu, each=N)
Z <- X0%*%A
mod_z <- BASS::bass(Z, Yf, verbose=FALSE)
pr <- list()
for(i in 1:p) pr[[i]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0, sd=1, weights=1)
Cbass_z <- C_bass(mod_z, prior=pr)
Cbass <- A%*%Cbass_z%*%A
Cbass
Cmc
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 5000
p <- 3
# Get true value of C matrix (with monte carlo)
mu <- rep(0.5, 3)
Sigma <- matrix(c(1, 0.5, -0.2,
0.5, 1, 0.1,
-0.2, 0.1, 1),
ncol=3, byrow=TRUE)/3
measure <- function() as.numeric(mvtnorm::rmvnorm(1, mu, Sigma))
Cmc <- C_mc(f, measure, nmc=5e4)
# Get estimate of C matrix (with C_bass)
X <- mvtnorm::rmvnorm(N, mu, Sigma)
Yf <- apply(X, 1, f)
Esig <- eigen(Sigma)
A <- Esig$vectors%*%diag(1/sqrt(Esig$values))%*%t(Esig$vectors)
X0 <- X - rep(mu, each=N)
Z <- X0%*%A
mod_z <- BASS::bass(Z, Yf, verbose=FALSE)
pr <- list()
for(i in 1:p) pr[[i]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0, sd=1, weights=1)
Cbass_z <- C_bass(mod_z, prior=pr)
Cbass <- A%*%Cbass_z%*%A
Cbass
Cmc
Cmc_z
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 5000
p <- 3
# Get true value of C matrix (with monte carlo)
mu <- rep(0.5, 3)
Sigma <- matrix(c(1, 0.5, -0.2,
0.5, 1, 0.1,
-0.2, 0.1, 1),
ncol=3, byrow=TRUE)/3
measure <- function() as.numeric(mvtnorm::rmvnorm(1, mu, Sigma))
Cmc_x <- C_mc(f, measure, nmc=1e4)
Esig <- eigen(Sigma)
A <- Esig$vectors%*%diag(1/sqrt(Esig$values))%*%t(Esig$vectors)
measure_z <- function() rnorm(3)
f_z <- function(z){
x <- mu + solve(A)%*%matrix(z, ncol=1)
f(x)
}
Cmc_z <- C_mc(f_z, measure_z, nmc=1e4)
Cmc_zx <- A%*%Cmc_z%*%A
Cmc_z
Cbass_z
d1 <- sum(abs(Cbass - Cmc))
d1
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 5000
p <- 3
# Get true value of C matrix (with monte carlo)
mu <- rep(0.5, 3)
Sigma <- matrix(c(1, 0.5, -0.2,
0.5, 1, 0.1,
-0.2, 0.1, 1),
ncol=3, byrow=TRUE)/3
measure <- function() as.numeric(mvtnorm::rmvnorm(1, mu, Sigma))
Cmc <- C_mc(f, measure, nmc=5e4)
# Get estimate of C matrix (with C_bass)
X <- mvtnorm::rmvnorm(N, mu, Sigma)
Yf <- apply(X, 1, f)
Esig <- eigen(Sigma)
A <- Esig$vectors%*%diag(1/sqrt(Esig$values))%*%t(Esig$vectors)
X0 <- X - rep(mu, each=N)
Z <- X0%*%A
mod_z <- BASS::bass(Z, Yf, verbose=FALSE)
pr <- list()
for(i in 1:p) pr[[i]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0, sd=1, weights=1)
Cbass_z <- C_bass(mod_z, prior=pr)
Cbass <- A%*%Cbass_z%*%A
d1 <- sum(abs(Cbass - Cmc))
d1
Cbass
Cmc
Cmc_z
Cbass_z
Cmc_z - Cbass_z
sum(abs(Cmc_z - Cbass_z))
sum(abs(Cbass - Cmc))
?bass
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 10000
p <- 3
# Get true value of C matrix (with monte carlo)
mu <- rep(0.5, 3)
Sigma <- matrix(c(1, 0.5, -0.2,
0.5, 1, 0.1,
-0.2, 0.1, 1),
ncol=3, byrow=TRUE)/3
measure <- function() as.numeric(mvtnorm::rmvnorm(1, mu, Sigma))
Cmc <- C_mc(f, measure, nmc=5e4)
# Get estimate of C matrix (with C_bass)
X <- mvtnorm::rmvnorm(N, mu, Sigma)
Yf <- apply(X, 1, f)
Esig <- eigen(Sigma)
A <- Esig$vectors%*%diag(1/sqrt(Esig$values))%*%t(Esig$vectors)
X0 <- X - rep(mu, each=N)
Z <- X0%*%A
mod_z <- BASS::bass(Z, Yf, verbose=FALSE)
pr <- list()
for(i in 1:p) pr[[i]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0, sd=1, weights=1)
Cbass_z <- C_bass(mod_z, prior=pr, nmcmc=30000, nburn=25000, thin=5)
mod_z <- BASS::bass(Z, Yf, verbose=FALSE, nmcmc=30000, nburn=25000, thin=5)
pr <- list()
for(i in 1:p) pr[[i]]  <- list(dist="normal", trunc=c(-Inf, Inf), mean=0, sd=1, weights=1)
Cbass_z <- C_bass(mod_z, prior=pr)
Cbass <- A%*%Cbass_z%*%A
Cbass
Cmc
