}
pred[i-nburn,]<-B%*%mod$beta[i,1:(mod$nbasis[i]+1)]
}
return(pred)
}
################################################################################################################
# test it out
#set.seed(46)
f <-function(x){ # the Friedman function
10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
#apply(x,1,borehole,scale01=T)
}
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y)
mod$count
plot(mod$nbasis,type='l')
plot(y,mod$X%*%mod$b); abline(a=0,b=1,col=2) # X and b are from the last MCMC iteration
plot(mod$s2[-c(1:1000)],type='l')
plot(mod$lam[-c(1:1000)],type='l')
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
mean(((colMeans(pred))-f(xtest))**2)
mod2 <- BASS::bass(x, y)
mean(((colMeans(pred))-f(xtest))**2)
pred2 <- predict(mod2, xtest)
dim(x)
dim(xtest)
pred2 <- predict(mod2, xtest)
pred2 <- BASS::predict(mod2, xtest)
pred2 <- BASS:::predict(mod2, xtest)
pred2 <- BASS:::predict.bass(mod2, xtest)
pred2
plot(f(xtest), colMeans(pred2))
mean(((colMeans(pred2))-f(xtest))**2)
mean(((colMeans(pred))-f(xtest))**2)
nu_vec <- c(0.05, 0.1, 0.2, 0.5, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y)
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
nu_vec <- c(0.05, 0.1, 0.2, 0.5, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
MSE
rowMeans(MSE)
plot(nu_vec, rowMeans(MSE))
plot(nu_vec, rowMeans(MSE))
length(nu_vec)
foo <- rep(NA, 3)
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
#mod<-bass(x,y, nu_birth=nu_vec[i])
mod<-bass(x,y, nu_birth=0.75)
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
foo[j] <- mean(((colMeans(pred))-f(xtest))**2)
#MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
mean(foo)
points(0.75, mean(foo))
mean(foo)
nu_vec <- c(0.05, 0.5, 0.5, 0.75 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
nu_vec <- c(0.05, 0.5, 0.5, 0.75, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
plot(nu_vec, rowMeans(MSE))
MSE
tmp_y <- rowMeans(MSE)
abline(h=0.098)
abline(h=0.092)
abline(h=0.082)
abline(h=0.077)
tmp_y <- c(tmp_y, c(0.99, 0.92, 0.82, 0.78, 0.83))
tmp_y
tmp_x <- c(nu_vec, c(0.05, 0.1, 0.2, 0.5, 1))
plot(tmp_x, tmp_y)
tmp_y <- rowMeans(MSE)
tmp_y <- c(tmp_y, c(0.099, 0.092, 0.082, 0.078, 0.083))
plot(tmp_x, tmp_y)
lm(I(log(tmp_y))~tmp_x)
lm(tmp_y ~ I(tmp_x^2))
curve(0.0879 + 0.00312*x^2)
plot(tmp_x, tmp_y)
curve(0.0879 + 0.00312*x^2, add=TRUE)
mean(((colMeans(pred2))-f(xtest))**2)
pred2 <- BASS:::predict.bass(mod2, xtest)
mean(((colMeans(pred2))-f(xtest))**2)
abline(h=0.0012)
library(devtools)
document()
?tr
matrix(0, 10)
prior_i
library(roxygen2)
library(devtools)
document()
library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
quack()
X <- lhs::maximinLHS(1000, 2)
y <- apply(X, 1, detpep_curve)
mod <- bass(X, y)
X <- lhs::maximinLHS(1000, 2)
y <- apply(X, 1, detpep_curve)
y
y <- apply(X, 1, duqling::detpep_curve)
mod <- bass(X, y)
duqling::detpep_curve
?duqling::detpep_curve
?duqling::detpep_curve(runif(3))
duqling::detpep_curve(runif(3))
X <- lhs::maximinLHS(1000, 3)
y <- apply(X, 1, duqling::detpep_curve)
mod <- bass(X, y)
Z_bass
Z = Z_bass(mod)
document()
Z = Z_bass(mod)
document()
Z = Z_bass(mod)
document()
Z = Z_bass(mod)
Z
y
plot(mod)
document()
Z = Z_bass(mod)
I4
I5
i4
i5
E0
E1
u
t
sm
tm
u
u
Z = Z_bass(mod)
um
sm
tm
um
tm
ssm
sm
E0
E1
a
a[m]
b[m]
document()
Z = Z_bass(mod)
Z
plot(sobol(mod))
document()
library(concordance)
document()
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
X <- lhs::maximinLHS(1000, 3)
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z_bass
Z
range(X)
?prior
rbind(X,X)
dim(rbind(X,X))
X <- lhs::maximinLHS(1000, 3)
X <- rbind(X,rep(1, 3), rep(0, 3))
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
# Get transformation matrix
A_tform <- diag(1/apply(mod$range.des, 2, diff))
A_tform
Z
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
X <- lhs::maximinLHS(1000, 3)
X <- rbind(X,rep(1, 3), rep(0, 3))
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
0.1*4000
0.9*4000
pbeta(0.5, 40, 360)
pbeta(0.2, 40, 360)
pbeta(0.11, 40, 360)
pbeta(0.11, 4, 36)
pbeta(0.5, 4, 36)
a <- 4
b <- 36
a*b/(a+b+1)/(a+b)^2
a*b/(a+b+1)/(a+b)^2
b <- 36
document()
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
X <- lhs::maximinLHS(1000, 3)
X <- rbind(X,rep(1, 3), rep(0, 3))
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
Z
document()
plot(mod)
Z
mod <- bass(X, y)
Z = Z_bass(mod)
Z
Z = Z_bass(mod)
Z
document()
Z = Z_bass(mod)
Z
document()
Z = Z_bass(mod)
Z = Z_bass(mod)
Z
document()
Z = Z_bass(mod)
Z
document()
Z = Z_bass(mod)
Z
range(X)
range(X[,1])
range(X[,2])
document()
Z = Z_bass(mod)
coeff
ss
sm
tm
E0a
E0
E1
document()
Z = Z_bass(mod)
Z
Z/Z[1]*1.5
1/3+1/2
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
X <- lhs::maximinLHS(1000, 3)
X <- rbind(X,rep(1, 3), rep(0, 3))
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
Z = Z_bass(mod)
Z = Z_bass(mod)
Z
document()
Z = Z_bass(mod)
sm
um
E0
sm*um*E0
i
m
ifelse(um == 0, sm*1, sm*(E1 - tm*E0))
sm*(E1 - tm*E0)
um
t
tm
sm
um
curve(pos(x-tm))
curve(pos(x-tm))
curve(BASS:::pos(x-tm))
document()
Z = Z_bass(mod)
coeff
I5
dim(I5)
length(coeff)
i=1
zi_curr <- coeff*I4[i,]
for(k in (1:mod$pdes)[-i]){
zi_curr <- zi_curr * I5[k,]
}
zi_curr
for(k in (1:mod$pdes)[-i]){
zi_curr <- zi_curr * I5[k,]
}
for(k in (1:mod$pdes)[-i]){
zi_curr <- zi_curr * I5[k,]
}
zi_curr
zi_curr <- coeff*I4[i,]
for(k in (1:mod$pdes)[-i]){
zi_curr <- zi_curr * I5[k,]
}
zi_curr
sum(zi_curr)
a
b
a
table(a)
table(b)
sm
sm == 1
tm
A
table(a)
table(b)
m
tm
sm
m
i
um <- u[m]
ssm <- s[m]
sm <- sign(ssm)
tm <- t[m]
um
a
table(a)
i = 1
prior_i <- prior[[i]]
prior_i
v <- apply(indic, 1, function(zz) match(i, zz))
u <- !is.na(v)
s <- apply(cbind(signs, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
gbass_flag
if(gbass_flag){
t <- apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
}else{
t <- Xt[apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]]), i]
}
# If this comes from BASS (rather than GBASS with gm2bm)
# then we need to account for Devin's g-scaling-factors
#if(!gbass_flag){
# NOTE: Need to comment out, i don't remember why
d <- 1/((s + 1)/2 - s*t)
s <- s*d
?concordance::fd_grad
fd_grad(f, X[1,])
Z
# COMPARE TO MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(Zmc)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(Zmc)
}
# COMPARE TO MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(Zmc)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(X)
}
nrow(X)
# COMPARE TO MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(X)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(X)
}
Zmc
Zmc
document()
Z_bass(mod)
document()
Z_bass(mod)
s
document()
Z_bass(mod)
m
tm
um
a
t
Z_bass(mod)
get("s")
dim(get("s"))
document()
Z_bass(mod)
document()
Z_bass(mod)
document()
Z_bass(mod)
document()
Z_bass(mod)
sm
document()
Z_bass(mod)
document()
Z_bass(mod)
document()
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
X <- lhs::maximinLHS(100, 3)
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
# COMPARE TO MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(X)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(X)
}
Zmc
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
# TRUE ANSWER IS (1.5, beta+0.5, 0)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
# WITH CONCORDANCE
X <- lhs::maximinLHS(100, 3)
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
# WITH MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(X)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(X)
}
Zmc
#library(duqling) #devtools::install_github("knrumsey/duqling")
library(BASS)
library(lhs)
# TRUE ANSWER IS (1.5, beta+0.5, 0)
f <- function(xx, beta=1/3) xx[1]^2 + xx[1]*xx[2] + beta*xx[2]^3
# WITH CONCORDANCE
X <- lhs::maximinLHS(100, 3)
y <- apply(X, 1, f)
mod <- bass(X, y)
Z = Z_bass(mod)
Z
# WITH MONTE CARLO
Zmc <- rep(0, 3)
for(i in 1:nrow(X)){
Zmc <- Zmc + fd_grad(f, X[i,])/nrow(X)
}
Zmc
library(concordance)
