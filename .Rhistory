fit_lc$wasfunc
document()
C_basst <- C_bass(fit_lc)
fit_lc$pfunc
document()
C_basst <- C_bass(fit_lc)
fit_lc <- concordance::lcbass2bass(mod_list, weights, yy=yy)
preds <- predict(fit_lc, X)
plot(colMeans(preds), yy)
C_basst <- C_bass(fit_lc)
eigen(C_basst)
plot(sqrt(act_scores(C_basst, k=3)))
# Not sure why plot method doesnt work
plot(fit_lc)
fit_lc <- concordance::lcbass2bass(mod_list, weights, yy=yy)
preds <- predict(fit_lc, X)
plot(colMeans(preds), yy)
# Not sure why plot method doesnt work
plot(fit_lc)
?predict.bass
# Not sure why plot method doesnt work
plot(fit_lc, X)
predict.bass
BASS:::predict.bass
plot(fitPCA)
BASS:::plot.bass
plot(fit_lc$y, fit_lc$yhat.mean)
plot(fit_lc$yhat.mean, colMeans(preds))
?Cfg_bass
?C_bass
?Cfg_bass
modPCA <- fitPCA
class(modPCA)
phi <- modPCA$dat$basis
dim(phi)
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list <- modPCA$mod.list
if(is.null(mcmc.use)) mcmc.use <- 1:length(mod_list[[1]]$s2)
C_bassPCA <- function(modPCA, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list <- modPCA$mod.list
if(is.null(mcmc.use)) mcmc.use <- 1:length(mod_list[[1]]$s2)
Ct <- list()
for(t in seq_along(func.use)){
tt <- func.use[t]
fit_lc_curr <- lcbass2bass(mod_list, weights=phi[tt,])
Ct[[t]] <- C_bass(fit_lc_curr, prior, mcmc.use)
}
return(Ct)
}
C_bassPCA(fitPCA)
C_bassPCA <- function(modPCA, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list <- modPCA$mod.list
Ct <- list()
for(t in seq_along(func.use)){
tt <- func.use[t]
fit_lc_curr <- lcbass2bass(mod_list, weights=phi[tt,])
Ct[[t]] <- C_bass(fit_lc_curr, prior, mcmc.use)
}
return(Ct)
}
Ct <- C_bassPCA(fitPCA)
length(Ct)
Ct[[3]]
tmp <- list()
tmp[[1,2]] <- "hey"
expand.grid(1:nbassmodels, 1:nbassmodels)
length(Ct)
unlist(Ct)
# Call C_bassPCA
C_bassPCA_type <- ifelse(type == 1, get("C_bassPCA"), get("C_bassPCA_v2"))
C_bassPCA <- function(modPCA, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list <- modPCA$mod.list
Ct <- list()
for(t in seq_along(func.use)){
tt <- func.use[t]
fit_lc_curr <- lcbass2bass(mod_list, weights=phi[tt,])
Ct[[t]] <- C_bass(fit_lc_curr, prior, mcmc.use)
}
return(Ct)
}
C_bassPCA_v2 <- function(modPCA, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list <- modPCA$mod.list
# Get Cij for all model pairs
nbassmodels <- length(modPCA)
Cij <- list()
cnt <- 1
for(i in 1:nbassmodels){
for(j in 1:nbassmodels){
if(i == j){
Cij[[cnt]] <- C_bass(mod_list[[i]], prior, mcmc.use)
}else{
Cij[[cnt]] <- Cfg_bass(mod_list[[i]], mod_list[[j]], prior, mcmc.use)
}
cnt <- cnt + 1
}
}
p <- nrow(Cij[[1]])
# Assemble C list for each t
Ct <- list()
cnt <- 1
for(t in seq_along(func.use)){
tt <- func.use[t]
Ctmp <- matrix(0, nrow=p, ncol=p)
for(i in 1:nbassmodels){
for(j in 1:nbassmodels){
Ctmp <- Ctmp + phi[tt,i]*phi[tt,j]*Cij[[cnt]]
cnt <- cnt + 1
}
}
Ct[[t]] <- Ctmp
}
return(Ct)
}
Cfg_bassPCA <- function(modPCA1, modPCA2, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi1 <- modPCA1$dat$basis
phi2 <- modPCA1$dat$basis
nfunc <- nrow(phi1)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list1 <- modPCA1$mod.list
mod_list2 <- modPCA2$mod.list
if(is.null(mcmc.use)) mcmc.use <- 1:length(mod_list1[[1]]$s2)
Cfgt <- list()
for(t in seq_along(func.use)){
tt <- func.use[t]
fit_lc_curr1 <- lcbass2bass(mod_list1, weights=phi1[tt,])
fit_lc_curr2 <- lcbass2bass(mod_list2, weights=phi2[tt,])
Cfgt[[t]] <- Cfg_bass(fit_lc_curr1, fit_lc_curr2, prior, mcmc.use)
}
return(Cfgt)
}
Cfg_bassPCA_v2 <- function(modPCA1, modPCA2, prior=NULL, mcmc.use=NULL, func.use=NULL){
if(class(modPCA) != "bassBasis") stop("modPCA must be an object with class bassBasis")
# Get weights matrix
phi1 <- modPCA1$dat$basis
phi2 <- modPCA2$dat$basis
if(any(dim(phi1) != dim(phi2))){
stop("modPCA$dat$basis should hve the same dimension for both models.")
}
nfunc <- nrow(phi1)
if(is.null(func.use)) func.use <- 1:nfunc
# Get model list
mod_list1 <- modPCA1$mod.list
mod_list2 <- modPCA2$mod.list
# Get Cij for all model pairs
nbassmodels1 <- length(modPCA1)
nbassmodels2 <- length(modPCA2)
Cij <- list()
cnt <- 1
for(i in 1:nbassmodels1){
for(j in 1:nbassmodels2){
Cij[[cnt]] <- Cfg_bass(mod_list1[[i]], mod_list2[[j]], prior, mcmc.use)
cnt <- cnt + 1
}
}
p <- nrow(Cij[[1]])
# Assemble C list for each t
Cfgt <- list()
cnt <- 1
for(t in seq_along(func.use)){
tt <- func.use[t]
Ctmp <- matrix(0, nrow=p, ncol=p)
for(i in 1:nbassmodels1){
for(j in 1:nbassmodels2){
Ctmp <- Ctmp + phi1[tt,i]*phi2[tt,j]*Cij[[cnt]]
cnt <- cnt + 1
}
}
Cfgt[[t]] <- Ctmp
}
return(Cfgt)
}
# Call C_bassPCA
C_bassPCA_type <- ifelse(type == 1, get("C_bassPCA"), get("C_bassPCA_v2"))
type
type = 1
if(is.null(prior_func)) prior_func <- rep(1/nfunc, nfunc)
# Get weights matrix
phi <- modPCA$dat$basis
nfunc <- nrow(phi)
if(is.null(func.use)) func.use <- 1:nfunc
func.use <- prior_func <- NULL
if(is.null(func.use)) func.use <- 1:nfunc
if(is.null(prior_func)) prior_func <- rep(1/nfunc, nfunc)
seq_along(func.use)[-1
]
document()
tr
?concordance:::tr
concordance:::tr
devtools::document()
?C_bass
C_bassPCA
?C_bassPCA
devtools::document()
plot(sob)
?duqling::pollutant
pollutant_modified <- function(X, xi, nfunc){
Z <- matrix(NA, nrow=nrow(X), ncol=4)
Z[1] <- X[1]
Z[2] <- X[2]
Z[3] <- (X[3]*2 + X[4])/3
Z[4] <- X[5]
duqling::pollutant(Z, space=xi, time=seq(0.3, 60, length.out=nfunc), scale01=TRUE)
}
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10)
pollutant_modified <- function(X, xi, nfunc){
Z <- matrix(NA, nrow=nrow(X), ncol=4)
Z[1] <- X[1]
Z[2] <- X[2]
Z[3] <- (X[3]*2 + X[4])/3
Z[4] <- X[5]
duqling::pollutant(Z, space=xi, time=seq(0.3, 60, length.out=nfunc), scale01=TRUE)
}
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10)
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10)
pollutant_modified(X[1,], 1.5, 10)
X + X[1,]
X = X[1,]
xi=1.5
nfunc = 10
Z <- matrix(NA, nrow=nrow(X), ncol=4)
Z[1] <- X[1]
Z <- rep(NA, 4)
Z[1] <- X[1]
Z[2] <- X[2]
Z[3] <- (X[3]*2 + X[4])/3
Z[4] <- X[5]
duqling::pollutant(Z, space=xi, time=seq(0.3, 60, length.out=nfunc), scale01=TRUE)
pollutant_modified <- function(X, xi, nfunc){
Z <- rep(NA, 4)
Z[1] <- X[1]
Z[2] <- X[2]
Z[3] <- (X[3]*2 + X[4])/3
Z[4] <- X[5]
duqling::pollutant(Z, space=xi, time=seq(0.3, 60, length.out=nfunc), scale01=TRUE)
}
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10)
dim(y1)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10)
y2 <- apply(X, 1, pollutant_modified, xi=2.0, nfunc=10)
var(y1)
var(unlist(y1))
var(unlist(y1))
unlist(y1)
as.numeric(y1)
var(as.numeric(y1))
sd(as.numeric(y1))
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10) + rnorm(200, 0, 0.5)
y2 <- apply(X, 1, pollutant_modified, xi=2.0, nfunc=10) + rnorm(200, 0, 0.5)
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10) + rnorm(200, 0, 0.5)
y2 <- apply(X, 1, pollutant_modified, xi=2.0, nfunc=10) + rnorm(200, 0, 0.5)
tt <- seq(0, 1, length.out=10)
# METHOD ONE
fit1 <- bass(X, y1, xx=tt)
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10) + rnorm(200, 0, 0.5)
y2 <- apply(X, 1, pollutant_modified, xi=2.0, nfunc=10) + rnorm(200, 0, 0.5)
tt <- seq(0, 1, length.out=10)
# METHOD ONE
fit1 <- bass(X, y1, xx=tt)
?bass
# METHOD ONE
fit1 <- bass(X, y1, xx.func=tt)
class(fit1)
fit2 <- bass(X, y2, xx.func=tt)
conc_method1 <- conc_bass(fit1, fit2)
C_bass(fit1)
C_bass(fit2)
Cfg_bass(fit1, fit2)
document()
conc_method1 <- conc_bass(fit1, fit2)
Cfg_bass(fit1, fit2)
mod1 = fit1
mod2 = fit2
prior = NULL
mcmc.use = NULL
is.matrix(out$Cf)
out$Cf <- C_bass(mod1, prior, mcmc.use)
out$Cfg <- Cfg_bass(mod1, mod2, prior, mcmc.use)
out$Cf <- C_bass(mod1, prior, mcmc.use)
class(mod1)
C_bass(fit1)
C_bass(fit1, prior, mcmc.use)
document()
conc_method1 <- conc_bass(fit1, fit2)
conc_method
conc_method1
names(conc_method1)
document()
conc_method1 <- conc_bass(fit1, fit2)
conc_method1
library(tictoc)
library(lhs)
library(BASS)
f1 <- function(x) x[1]^2 + x[1]*x[2]
f2 <- function(x, beta=1/9) x[1]^2 + x[1]*x[2] + beta*x[2]^3
X <- lhs::maximinLHS(5000, 2)
library(tictoc)
library(lhs)
library(BASS)
f1 <- function(x) x[1]^2 + x[1]*x[2]
f2 <- function(x, beta=1/9) x[1]^2 + x[1]*x[2] + beta*x[2]^3
X <- lhs::randomLHS(5000, 2)
y1 <- apply(X, 1, f1)
y2 <- apply(X, 1, f2, beta=3)
tic()
m1 <- bass(X, y1)
t1 = toc()
tic()
m2 <- bass(X, y2)
library(tictoc)
library(lhs)
library(BASS)
f1 <- function(x) x[1]^2 + x[1]*x[2]
f2 <- function(x, beta=1/9) x[1]^2 + x[1]*x[2] + beta*x[2]^3
X <- lhs::randomLHS(1000, 2)
y1 <- apply(X, 1, f1)
y2 <- apply(X, 1, f2, beta=3)
tic()
m1 <- bass(X, y1)
t1 = toc()
tic()
m2 <- bass(X, y2)
t2 = toc()
tic()
C1  <- C_bass(m1)
mod$pfunc
document()
tic()
C1  <- C_bass(m1)
C2  <- C_bass(m2)
C12 <- Cfg_bass(m1, m2)
document()
tic()
C1  <- C_bass(m1)
C2  <- C_bass(m2)
C12 <- Cfg_bass(m1, m2)
t3 = toc()
sum(diag(C12))/sqrt(sum(diag(C1)*sum(diag(C2))))
conc_method1 <- conc_bass(fit1, fit2)
conc_method1$conc
conc_method1$Cfg
C_bass(fit1)
C_bass(fit2)
Cfg_bass(fit2)
Cfg_bass(fit1, fit2)
conc_method1$Cf
conc_method1$Cg
conc_method1$Cf
Cfg_bass(fit1, fit2)
Cfg_bass(m1, m2)
document()
Cfg_bass(fit1, fit2)
mod
mod1
knots2
v2
t2 <- apply(cbind(knots2, v2), 1, function(zz) zz[zz[mod2$maxInt.des + 1]])
t2
v2
u2
s2
t2
knots2
cbind(knots2, v2)
t2 <- apply(cbind(knots2, v2), 1, function(zz) zz[zz[mod2$maxInt.des + 1]])
t2
t
v
u
Cfg_bass(fit1, fit2)
knots
v
knots
knots2
dim(knots2)
dim(knots())
dim(knots
)
dim(knots2)
C_bass(fit1)
dim(C_bass(fit1))
dim(C_bass(fit2))
dim(mod2$knotInd.des)
dim(mod1$knotInd.des)
dim(fit1$knotInd.des)
dim(fit2$knotInd.des)
Cfg_bass(fit1, fit2)
dim(knots)
dim(mod$knotInd.des)
dim(mod2$knotInd.des)
mod <- bassfunc2bass(fit1)
dim(mod$knotInd.des)
mod2 <- bassfunc2bass(fit2)
dim(mod2$knotInd.des)
document()
Cfg_bass(fit1, fit2)
dim(mod$knotInd.des)
dim(mod$knotInd.des)
knots
dim(knots)
mod_number
mod_number2
dim(knots)
dim(knots2)
r
rr
rr1
rr2
compute_flag
dim(v)
v
dim(vars)
indic
var(indic)
dim(indic)
dim(indic2)
dim(knots2)
dim(signs2)
knots2      <- mod2$knotInd.des[mod_number2, 1:M2, ]
knots2
dim(knots2)
dim(mod2$knotInd.des)
mod2$knotInd.des[mod_number2, 1:M2, ]
dim(mod2$knotInd.des)
dim(mod2$vars.des)
dim(mod$vars.des)
dim(mod$knotInd.des)
mod1 <- bassfunc2bass(fit1)
mod2 <- bassfunc2bass(fit2)
mod = mod1
dim(mod1$knotInd.des)
dim(mod1$vars.des)
dim(mod2$vars.des)
dim(mod2$knotInd.des)
mod1$maxInt.des
mod2$maxInt.des
dim(fit1$knotInd.des)
dim(fit2$knotInd.des)
dim(fit2$knotInd.func)
dim(fit1$knotInd.func)
mod1$knots.des
dim(mod1$knots.des)
dim(mod2$knots.des)
document()
conc_method1 <- conc_bass(fit1, fit2)
conc_method1$conc
conc_method1$Cfg_bass
conc_method1$Cfg
conc_method1$Cf
conc_method1$Cg
conc_method1$Cfg
mod1$pdes
mod1$p
document()
fit1 <- bass(X, y1, xx.func=tt)
conc_method1 <- conc_bass(fit1, fit2)
conc_method1$conc
conc_method1$Cfg
# METHOD TWO (Analyze as a function of t)
fitPCA1 <- bassPCA(X, y)
# METHOD TWO (Analyze as a function of t)
fitPCA1 <- bassPCA(X, y1)
dim(y1)
X <- lhs::maximinLHS(200, 5)
y1 <- apply(X, 1, pollutant_modified, xi=1.5, nfunc=10) + rnorm(200, 0, 0.5)
y2 <- apply(X, 1, pollutant_modified, xi=2.0, nfunc=10) + rnorm(200, 0, 0.5)
tt <- seq(0, 1, length.out=10)
dim(y1)
# METHOD TWO (Analyze as a function of t)
fitPCA1 <- bassPCA(X, y1)
fitPCA2 <- bassPCA(X, y2)
?C_bassPCA
conc_method1 <- conc_bass(fitPCA1, fitPCA2)
conc_method1 <- conc_bass(fitPCA1, fitPCA2, type=2)
