compute_flag <- FALSE
if(r == 1){
compute_flag <- TRUE
}else{
if(mod_number != mod_number_new){
compute_flag <- TRUE
}
}
mod_number <- mod_number_new
M          <- M_new
knots      <- mod$knotInd.des[mod_number, 1:M, ]
signs      <- mod$signs.des[mod_number, 1:M, ]
indic      <- mod$vars.des[mod_number, 1:M, ]
knots
signs
indic
# Initalize arrays
C <- A <- B <- I1 <- I2 <- I3 <- array(NA, dim=c(mod$pdes, M, M))
i
prior_i <- prior[[i]]
v <- apply(indic, 1, function(zz) match(i, zz))
u <- !is.na(v)
s <- apply(cbind(signs, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
s
v
u
Xt[apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]]), i]
mod = hold
apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]]), i
apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
Xt
Xt[apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]]), i]
#Compute only the stuff we will need for every iteration
rr <- mcmc.use[r]
mod_number_new <- mod$model.lookup[rr]
coeff      <- mod$beta[rr,]
coeff      <- matrix(coeff[!is.na(coeff)][-1], nrow=1)
M_new <- length(coeff)
compute_flag <- FALSE
if(r == 1){
compute_flag <- TRUE
}else{
if(mod_number != mod_number_new){
compute_flag <- TRUE
}
}
mod_number <- mod_number_new
M          <- M_new
knots      <- mod$knotInd.des[mod_number, 1:M, ]
signs      <- mod$signs.des[mod_number, 1:M, ]
indic      <- mod$vars.des[mod_number, 1:M, ]
# Initalize arrays
C <- A <- B <- I1 <- I2 <- I3 <- array(NA, dim=c(mod$pdes, M, M))
prior_i <- prior[[i]]
v <- apply(indic, 1, function(zz) match(i, zz))
u <- !is.na(v)
s <- apply(cbind(signs, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
v
u
s
indic
s
apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
v
cbind(knots, v)
knots
mod$knots.des
foo$knotInd.des
dim(foo$knotInd.des)
dim(mod$knots.des)
knots    <- mod$knots.des[mod_number, 1:M, ]
knots
signs
s
u
s
v
signs
indic
s
knots
cbind(knots, v)
apply(cbind(knots, v), 1, function(zz) zz[zz[mod$maxInt.des + 1]])
document()
devtools::document()
library(concordance)
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(500, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod <- tbass(X, y)
mod_b <- gm2bm(mod)
sob <- sobol(mod_b)
C <- C_bass(mod_b)
C
prior = NULL
mcmc.use=NULL
scaled=FALSE
if(is.null(mcmc.use)){
mcmc.use <- length(mod$nbasis)
}
gbass_flag <- "gbass" %in% class(mod)
if(gbass_flag){
mod$knotInd.des <- mod$knots.des
}
# Parse the prior information
if(is.null(prior)){
prior <- list()
for(i in 1:mod$pdes){
prior[[i]] <- list(dist="uniform")
}
}
mod_g <- mod
mod <- mod_b
if(is.null(mcmc.use)){
mcmc.use <- length(mod$nbasis)
}
gbass_flag <- "gbass" %in% class(mod)
if(gbass_flag){
mod$knotInd.des <- mod$knots.des
}
# Parse the prior information
if(is.null(prior)){
prior <- list()
for(i in 1:mod$pdes){
prior[[i]] <- list(dist="uniform")
}
}
#HANDLE PRIORS
for(i in 1:(mod$pdes)){
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- BASS:::scale.range(prior[[i]]$trunc, mod$range.des[,i])
# 2. Handle ach distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- BASS:::scale.range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc # DF: prior[[i]]$z # change weights with truncation # divide by cc instead to keep the same prior shape# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.0005, 0.9995), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "uniform"){
prior[[i]]$weights = 1
#Check for extrapolation
if(((prior[[i]]$trunc[1] < 0 - 0.1) | (prior[[i]]$trunc[2] > 1 + 0.1))){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "beta"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01 | abs(max(mod$xx.des[,i]) - 1) > 0.01){
warning("For dist=\"beta\", data should be scaled to (0, 1) range BEFORE fitting bass model")
}
}
if(distribution == "gamma"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01){
warning("For dist=\"gamma\", data should be shifted to have a minimum of 0 BEFORE fitting bass model")
}
prior[[i]]$rate = prior[[i]]$rate * prior[[i]]$trunc[2]
}
}
prior = NULL
mcmc.use=NULL
scaled=FALSE
if(is.null(mcmc.use)){
mcmc.use <- length(mod$nbasis)
}
gbass_flag <- "gbass" %in% class(mod)
if(gbass_flag){
mod$knotInd.des <- mod$knots.des
}
# Parse the prior information
if(is.null(prior)){
prior <- list()
for(i in 1:mod$pdes){
prior[[i]] <- list(dist="uniform")
}
}
#HANDLE PRIORS
for(i in 1:(mod$pdes)){
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- BASS:::scale.range(prior[[i]]$trunc, mod$range.des[,i])
# 2. Handle ach distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- BASS:::scale.range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc # DF: prior[[i]]$z # change weights with truncation # divide by cc instead to keep the same prior shape# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.0005, 0.9995), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "uniform"){
prior[[i]]$weights = 1
#Check for extrapolation
if(((prior[[i]]$trunc[1] < 0 - 0.1) | (prior[[i]]$trunc[2] > 1 + 0.1))){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "beta"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01 | abs(max(mod$xx.des[,i]) - 1) > 0.01){
warning("For dist=\"beta\", data should be scaled to (0, 1) range BEFORE fitting bass model")
}
}
if(distribution == "gamma"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01){
warning("For dist=\"gamma\", data should be shifted to have a minimum of 0 BEFORE fitting bass model")
}
prior[[i]]$rate = prior[[i]]$rate * prior[[i]]$trunc[2]
}
}
# Make constantine matrix
Cf_post <- list()
if(!gbass_flag){
Xt <- mod$xx.des
}
# Get transformation matrix
A_tform <- diag(1/apply(mod$range.des, 2, diff))
r=1
i=1
#Compute only the stuff we will need for every iteration
rr <- mcmc.use[r]
mod_number_new <- mod$model.lookup[rr]
coeff      <- mod$beta[rr,]
coeff      <- matrix(coeff[!is.na(coeff)][-1], nrow=1)
M_new <- length(coeff)
compute_flag <- FALSE
if(r == 1){
compute_flag <- TRUE
}else{
if(mod_number != mod_number_new){
compute_flag <- TRUE
}
}
mod_number <- mod_number_new
M          <- M_new
signs      <- mod$signs.des[mod_number, 1:M, ]
indic      <- mod$vars.des[mod_number, 1:M, ]
if(gbass_flag){
knots    <- mod$knots.des[mod_number, 1:M, ]
}else{
knots    <- mod$knotInd.des[mod_number, 1:M, ]
}
knots
gbass_flag
class(mod)
class(mod_g)
mod <- mod_g
class(mod_b)
mod_b <- gm2bm(mod)
mod_b
class(mod_b)
mod_b <- gm2bm(mod_g)
class(mod_g)
class(mod_b)
library(GBASS)
GBASS::gm2bm
detach("package:GBASS", unload = TRUE)
library(GBASS)
GBASS::gm2bm()
GBASS::gm2bm
mod
mod_b <- gm2bm(mod)
mod_g
mod <- gm2bm(mod_g)
class(mod)
sobol(mod)
sob <- sobol(mod)
C <- C_bass(mod)
C
foo = bass(X, y)
C_bass(foo)
plot(foo)
plot(mod)
plot(mod_g)
plot(foo)
C
class(mod)
C_bass(mod)
C_bass(foo)
matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(500, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
eigen(C)
document()
devtools::document()
C_bass
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y)
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y, t=20)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y, df=100)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
t
knots
?gbass
mod_g <- nwbass2(X, y, df=100)
mod_g <- nwbass2(X, y)
?nwbass
mod_g <- nwbass(X, y)
nwbass2
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- nwbass(X, y)
#sob <- sobol(mod)
C <- C_bass(mod)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
mod_g <- tbass(X, y, df=200)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
devtools::document()
#sob <- sobol(mod)
C <- C_bass(mod)
C
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
#C_true
matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.01)
y[1:5] <- y[1:5] + rnorm(0.5)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 1000
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:5] <- y[1:5] + rnorm(n, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 500
n_corrupted <- 5
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:n_corrupted] <- y[1:n_corrupted] + rnorm(n_corrupted, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
mod1 <- tbass(X, y, df=5)
mod1 <- gm2bm(mod1)
# Get C matrices
C0 <- C_bass(mod0)
C1 <- C_bass(mod1)
Ctrue <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Get error
D0 <- C0 - Ctrue
D1 <- C1 - Ctrue
sum(abs(D0))
sum(abs(D1))
#Print matrices
C0
C1
Ctrue
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(11111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 500
n_corrupted <- 5
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:n_corrupted] <- y[1:n_corrupted] + rnorm(n_corrupted, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
mod1 <- tbass(X, y, df=5)
mod1 <- gm2bm(mod1)
# Get C matrices
C0 <- C_bass(mod0)
C1 <- C_bass(mod1)
Ctrue <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Get error
D0 <- C0 - Ctrue
D1 <- C1 - Ctrue
sum(abs(D0))
sum(abs(D1))
#Print matrices
C0
C1
Ctrue
D <- matrix(rnorm(25), nrow=5)
D%*%D
crossprod(D)
tcrossprod(D)
D%*%t(D)
devtools::document()
library(concordance)
install.packages("badger")
