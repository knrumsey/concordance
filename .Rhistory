+ nint.cand*log(1/2)  # signs
+ dps_mix(W_star,w = W,d=d,nu = .2,j = nint.cand)
+ log(nbasis[i-1]+1) # ordering
)
lprop.alpha <- ( # log proposal ratio
# probability of going from proposed to current (death)
log(1/3) + # probability of selection a death step
+ log(1/(nbasis[i-1]+1)) # probability that this basis function is selected to kill
# probability of going from current to proposed
- (
log(1/3) # probability of selecting a birth step
+ log(1/max.int) # probability of nint.cand
+ nint.cand*log(1/2) # probability of the signs we got
+ dps_mix(W_star,w = W,d=d,nu = .2,j = nint.cand)
)
)
alpha <- llik.alpha + lprior.alpha + lprop.alpha
if(log(runif(1))<alpha){ # accept, update current values
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
nbasis[i]<-nbasis[i-1]+1
nint[i,nbasis[i]]<-nint.cand
knots[i,nbasis[i],1:nint.cand]<-knots.cand
signs[i,nbasis[i],1:nint.cand]<-signs.cand
# vars[i,nbasis[i],1:nint.cand]<-vars.cand
rotation_mat[i,nbasis[i],1:nrow(W_star),]<-W_star
count[1]<-count[1]+1
}
} else if(move.type=='death'){
tokill<-sample(nbasis[i-1],1) # which basis function we will delete
X.cand<-X.curr[,-(tokill+1)] # +1 to skip the intercept
W_star <- rotation_mat[i-1,tochange,1:length(nint[i-1,tokill]),] #t(X %*% t(W_star))
if (is.null(dim(W_star))){
W_star <- matrix(W_star,nrow=1)
}
Vinv.cand<-crossprod(X.cand)+diag(nbasis[i-1])/tau2
bhat.cand<-pd.solve(Vinv.cand)%*%crossprod(X.cand,y)
d.cand <- g2 + ssy - crossprod(bhat.cand,Vinv.cand%*%bhat.cand)
llik.alpha <- -.5*log(1/tau2) - determinant(Vinv.cand)$mod/2 + determinant(Vinv.curr)$mod/2 + (g1+n/2)*(log(d.curr) - log(d.cand))
lprior.alpha <- (
-log(lam[i-1])+log(nbasis[i-1]) # nbasis
- log(1/max.int)  # nint
- nint[i-1,tokill]*log(1/2)  # signs
-  dps_mix(W_star,w = W,d=d,nu = .2,j = nint.cand)
- log(nbasis[i-1]) # ordering
)
lprop.alpha <- (
# probability of going from proposed to current (birth)
log(1/3) # probability of selecting a birth step
+ log(1/max.int) # probability of nint
+ nint[i-1,tokill]*log(1/2) # probability of the signs we got
+  dps_mix(W_star,w = W,d=d,nu = .2,j = nint.cand)
# probability of going from current to proposed
- (
log(1/3) # probability of selection a death step
+ log(1/nbasis[i-1]) # probability that this basis function is selected to kill
)
)
alpha <- llik.alpha + lprior.alpha + lprop.alpha
if(log(runif(1))<alpha){ # accept, update
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
nbasis[i]<-nbasis[i-1]-1
nint[i,]<-NA
knots[i,,]<-signs[i,,]<-vars[i,,]<-NA
if(nbasis[i]==0){
nint[i,]<-NA
} else{
nint[i,1:nbasis[i]]<-nint[i-1,(1:nbasis[i-1])[-tokill]]
knots[i,1:nbasis[i],]<-knots[i-1,(1:nbasis[i-1])[-tokill],]
signs[i,1:nbasis[i],]<-signs[i-1,(1:nbasis[i-1])[-tokill],]
#  vars[i,1:nbasis[i],]<-vars[i-1,(1:nbasis[i-1])[-tokill],]
rotation_mat[i,1:nbasis[i],,]<-rotation_mat[i-1,(1:nbasis[i-1])[-tokill],,]
}
count[2]<-count[2]+1
}
} else{
tochange<-sample(nbasis[i-1],1) # which basis function we will change
tochange2<-sample(nint[i-1,tochange],1) # which element in the basis function tensor product we will change
knots.cand<-knots[i-1,tochange,1:nint[i-1,tochange]] # copy
knots.cand[tochange2]<-runif(1,min(X_star_rot),max(X_star_rot)) # change one element
W_star <- rotation_mat[i-1,tochange,1:length(knots.cand),] #t(X %*% t(W_star))
if (is.null(dim(W_star))){
W_star <- matrix(W_star,nrow=1)
}
X_star_rot <- t(X %*% t(W_star))
signs.cand<-signs[i-1,tochange,1:nint[i-1,tochange]] # copy
signs.cand[tochange2]<-sample(c(-1,1),1) # change on element
basis<-makeBasis(signs.cand,vars[i-1,tochange,1:nint[i-1,tochange]],knots.cand,(X_star_rot)) # remake the changed basis function
X.cand<-X.curr
X.cand[,tochange+1]<-basis # replace with our new basis function (+1 for intercept)
Vinv.cand<-crossprod(X.cand)+diag(nbasis[i-1]+1)/tau2
bhat.cand<-pd.solve(Vinv.cand)%*%crossprod(X.cand,y)
d.cand <- g2 + ssy - crossprod(bhat.cand,Vinv.cand%*%bhat.cand)
llik.alpha <- -determinant(Vinv.cand)$mod/2 + determinant(Vinv.curr)$mod/2 + (g1+n/2)*(log(d.curr) - log(d.cand))
alpha <- llik.alpha # the proposals and priors all cancel since there is no dimension change
if(log(runif(1))<alpha){ # accept, update
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
knots[i,tochange,1:nint[i,tochange]]<-knots.cand
signs[i,tochange,1:nint[i,tochange]]<-signs.cand
#rotation_mat[i,tochange,1:nrow(W_star),] <- W_star
count[3]<-count[3]+1
}
}
if (length(dim(X.curr)) <2){
X.curr <- matrix(X.curr,ncol=1)
}
## Gibbs steps
lam[i]<-rgamma(1,h1+nbasis[i],h2+1) # update lambda
S<-pd.solve(crossprod(X.curr)/s2[i-1]+diag(nbasis[i]+1)/tau2) # covariance matrix for beta update
beta[i,1:(nbasis[i]+1)]<-rmnorm(1,S%*%t(X.curr)%*%y/s2[i-1],S) # update beta
s2[i]<-1/rgamma(1,n/2+g1,rate=g2+.5*sum((y-X.curr%*%beta[i,1:(nbasis[i]+1)])^2)) # update s2
}
return(list(X=X.curr,rotation_mat=rotation_mat,b=bhat,count=count,knots=knots,signs=signs,vars=vars,nint=nint,nbasis=nbasis,beta=beta,s2=s2,lam=lam))
}
predict.bass<-function(mod,X,nburn=1000){ # prediction function, gets a prediction for each MCMC iteration
nmcmc<-length(mod$nbasis)
pred<-matrix(nrow=nmcmc-nburn,ncol=nrow(X))
for(i in (nburn+1):nmcmc){
B<-matrix(nrow=nrow(X),ncol=mod$nbasis[i]+1)
B[,1]<-1
for(j in 1:mod$nbasis[i]){
tmptmptmp <- mod$rotation_mat[i,j,1:mod$nint[i,j],]
if (is.null(dim(tmptmptmp))){
tmptmptmp <- matrix(tmptmptmp,nrow=1)
}
X_star_rot <- t(X %*% t(tmptmptmp))
B[,j+1]<-makeBasis(mod$signs[i,j,1:mod$nint[i,j]],mod$vars[i,j,1:mod$nint[i,j]],mod$knots[i,j,1:mod$nint[i,j]],X_star_rot)
}
pred[i-nburn,]<-B%*%mod$beta[i,1:(mod$nbasis[i]+1)]
}
return(pred)
}
################################################################################################################
# test it out
set.seed(46)
f <-function(x){ # the Friedman function
10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
#apply(x,1,borehole,scale01=T)
}
################################################################################################################
# test it out
#set.seed(46)
f <-function(x){ # the Friedman function
10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
#apply(x,1,borehole,scale01=T)
}
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y)
# function to fit the model (get posterior samples).  First samples the basis functions with RJMCMC, then samples everything else with gibbs sampling; follows Denison, Mallick, and Smith (1998) (DMS) except for when proposing a birth.
bass<-function(X, # training input matrix
y, # training response vector
max.int=3, # maximum degree of interaction (Jmax)
max.basis=100, # maximum nuber of basis functions
tau2=10^4, # prior variance for basis coefficients
nmcmc=10000, # number of MCMC iterations
g1=0,g2=0, # shape and scale for IG prior on sigma^2 (this default is the Jeffrey's prior)
h1=10,h2=10, # shape and rate for Gamma prior on mean number of basis functions (number of basis functions nbasis has Poisson(lam) prior where lam has a Gamma hyperprior => marginal prior for nbasis is negative binomial)
nu_birth=0.2, nu_change=0.2
){
W_tot = eigen(C_bass(BASS::bass(X,y)))
W = W_tot$vectors
d = W_tot$values
##### dimensions
Xt<-t(X)
n<-length(y)
p<-ncol(X)
ssy<-sum(y^2)
# storage
knots<-signs<-vars<-array(dim=c(nmcmc,max.basis,max.int)) # this is the largest possible, our filling will be ragged
rotation_mat <- array(dim=c(nmcmc,max.basis,ncol(X),ncol(X)))
nint<-matrix(nrow=nmcmc,ncol=max.basis) # degree of interaction J, again filling will be ragged
beta<-matrix(nrow=nmcmc,ncol=max.basis+1) # +1 for intercept, again filling will be ragged
s2<-lam<-nbasis<-rep(NA,nmcmc) # error variance, poisson hyperprior, and number of basis functions
# initialize
nbasis[1]<-0
s2[1]<-1
lam[1]<-1
X.curr<-matrix(rep(1,n)) # matrix of current basis functions, so that yhat = X.curr %*% beta
Vinv.curr<-crossprod(X.curr)+1/tau2 # V^(-1) from DMS
bhat<-pd.solve(Vinv.curr)%*%t(X.curr)%*%y
d.curr <- g2 + ssy - t(bhat)%*%Vinv.curr%*%bhat # d from DMS
count<-c(0,0,0) # count how many times we accept birth, death, change
beta[1,1]<-bhat
# start MCMC
for(i in 2:nmcmc){
## Reversible jump step
move.type<-sample(c('birth','death','change'),1)
if(nbasis[i-1]==0)
move.type<-'birth'
if(nbasis[i-1]==max.basis)
move.type<-sample(c('death','change'),1)
# set all of this iterations values to last iteration values...we'll change them if we accpet a move below
nbasis[i]<-nbasis[i-1]
nint[i,]<-nint[i-1,]
knots[i,,]<-knots[i-1,,]
signs[i,,]<-signs[i-1,,]
vars[i,,]<-vars[i-1,,]
rotation_mat[i,,,] <- rotation_mat[i-1,,,]
if(move.type=='birth'){
nint.cand<-sample(max.int,1) # sample degree of interaction for new basis function (different from DMS)
#vars.cand<-sample(p,nint.cand,replace = F) # variables to use in new basis function (different from DMS)
W_star <- rps_mix(W,d,.2,nint.cand)
X_star_rot <- t(X %*% t(W_star))
knots.cand<-X_star_rot[,sample(1:ncol(X_star_rot),1)] # sample knots for new basis function
signs.cand<-sample(c(-1,1),nint.cand,replace = T) # signs for new basis function
basis.cand<-makeBasis(signs.cand,1:nrow(X_star_rot),knots.cand,X_star_rot) # make the new basis function
X.cand<-cbind(X.curr,basis.cand) # add the new basis function to the basis functions we already have
Vinv.cand<-crossprod(X.cand)+diag(nbasis[i-1]+2)/tau2 # +2: one for intercept and one for birth
bhat.cand<-pd.solve(Vinv.cand)%*%t(X.cand)%*%y
d.cand <- g2 + ssy - t(bhat.cand)%*%Vinv.cand%*%bhat.cand
llik.alpha <- .5*log(1/tau2) - determinant(Vinv.cand)$mod/2 + determinant(Vinv.curr)$mod/2 + (g1+n/2)*(log(d.curr) - log(d.cand)) # calculate the log likelihood ratio (sort of) after integrating out beta and s2
lprior.alpha <- ( # log prior ratio
log(lam[i-1])-log(nbasis[i-1]+1) # nbasis
+ log(1/max.int)  # nint
+ nint.cand*log(1/2)  # signs
+ dps_mix(W_star,w = W,d=d,nu = nu_birth,j = nint.cand)
+ log(nbasis[i-1]+1) # ordering
)
lprop.alpha <- ( # log proposal ratio
# probability of going from proposed to current (death)
log(1/3) + # probability of selection a death step
+ log(1/(nbasis[i-1]+1)) # probability that this basis function is selected to kill
# probability of going from current to proposed
- (
log(1/3) # probability of selecting a birth step
+ log(1/max.int) # probability of nint.cand
+ nint.cand*log(1/2) # probability of the signs we got
+ dps_mix(W_star,w = W,d=d,nu = nu_birth,j = nint.cand)
)
)
alpha <- llik.alpha + lprior.alpha + lprop.alpha
if(log(runif(1))<alpha){ # accept, update current values
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
nbasis[i]<-nbasis[i-1]+1
nint[i,nbasis[i]]<-nint.cand
knots[i,nbasis[i],1:nint.cand]<-knots.cand
signs[i,nbasis[i],1:nint.cand]<-signs.cand
# vars[i,nbasis[i],1:nint.cand]<-vars.cand
rotation_mat[i,nbasis[i],1:nrow(W_star),]<-W_star
count[1]<-count[1]+1
}
} else if(move.type=='death'){
tokill<-sample(nbasis[i-1],1) # which basis function we will delete
X.cand<-X.curr[,-(tokill+1)] # +1 to skip the intercept
W_star <- rotation_mat[i-1,tokill,1:length(nint[i-1,tokill]),] #t(X %*% t(W_star))
if (is.null(dim(W_star))){
W_star <- matrix(W_star,nrow=1)
}
Vinv.cand<-crossprod(X.cand)+diag(nbasis[i-1])/tau2
bhat.cand<-pd.solve(Vinv.cand)%*%crossprod(X.cand,y)
d.cand <- g2 + ssy - crossprod(bhat.cand,Vinv.cand%*%bhat.cand)
llik.alpha <- -.5*log(1/tau2) - determinant(Vinv.cand)$mod/2 + determinant(Vinv.curr)$mod/2 + (g1+n/2)*(log(d.curr) - log(d.cand))
lprior.alpha <- (
-log(lam[i-1])+log(nbasis[i-1]) # nbasis
- log(1/max.int)  # nint
- nint[i-1,tokill]*log(1/2)  # signs
-  dps_mix(W_star,w = W,d=d,nu = nu_birth,j = nint.cand)
- log(nbasis[i-1]) # ordering
)
lprop.alpha <- (
# probability of going from proposed to current (birth)
log(1/3) # probability of selecting a birth step
+ log(1/max.int) # probability of nint
+ nint[i-1,tokill]*log(1/2) # probability of the signs we got
+  dps_mix(W_star,w = W,d=d,nu = nu_birth,j = nint.cand)
# probability of going from current to proposed
- (
log(1/3) # probability of selection a death step
+ log(1/nbasis[i-1]) # probability that this basis function is selected to kill
)
)
alpha <- llik.alpha + lprior.alpha + lprop.alpha
if(log(runif(1))<alpha){ # accept, update
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
nbasis[i]<-nbasis[i-1]-1
nint[i,]<-NA
knots[i,,]<-signs[i,,]<-vars[i,,]<-NA
if(nbasis[i]==0){
nint[i,]<-NA
} else{
nint[i,1:nbasis[i]]<-nint[i-1,(1:nbasis[i-1])[-tokill]]
knots[i,1:nbasis[i],]<-knots[i-1,(1:nbasis[i-1])[-tokill],]
signs[i,1:nbasis[i],]<-signs[i-1,(1:nbasis[i-1])[-tokill],]
#  vars[i,1:nbasis[i],]<-vars[i-1,(1:nbasis[i-1])[-tokill],]
rotation_mat[i,1:nbasis[i],,]<-rotation_mat[i-1,(1:nbasis[i-1])[-tokill],,]
}
count[2]<-count[2]+1
}
} else{
tochange<-sample(nbasis[i-1],1) # which basis function we will change
tochange2<-sample(nint[i-1,tochange],1) # which element in the basis function tensor product we will change
knots.cand<-knots[i-1,tochange,1:nint[i-1,tochange]] # copy
knots.cand[tochange2]<-runif(1,min(X_star_rot),max(X_star_rot)) # change one element
W_star <- rotation_mat[i-1,tochange,1:length(knots.cand),] #t(X %*% t(W_star))
if (is.null(dim(W_star))){
W_star <- matrix(W_star,nrow=1)
}
X_star_rot <- t(X %*% t(W_star))
signs.cand<-signs[i-1,tochange,1:nint[i-1,tochange]] # copy
signs.cand[tochange2]<-sample(c(-1,1),1) # change on element
basis<-makeBasis(signs.cand,vars[i-1,tochange,1:nint[i-1,tochange]],knots.cand,(X_star_rot)) # remake the changed basis function
X.cand<-X.curr
X.cand[,tochange+1]<-basis # replace with our new basis function (+1 for intercept)
Vinv.cand<-crossprod(X.cand)+diag(nbasis[i-1]+1)/tau2
bhat.cand<-pd.solve(Vinv.cand)%*%crossprod(X.cand,y)
d.cand <- g2 + ssy - crossprod(bhat.cand,Vinv.cand%*%bhat.cand)
llik.alpha <- -determinant(Vinv.cand)$mod/2 + determinant(Vinv.curr)$mod/2 + (g1+n/2)*(log(d.curr) - log(d.cand))
alpha <- llik.alpha # the proposals and priors all cancel since there is no dimension change
if(log(runif(1))<alpha){ # accept, update
X.curr<-X.cand
bhat<-bhat.cand
Vinv.curr<-Vinv.cand
d.curr<-d.cand
knots[i,tochange,1:nint[i,tochange]]<-knots.cand
signs[i,tochange,1:nint[i,tochange]]<-signs.cand
#rotation_mat[i,tochange,1:nrow(W_star),] <- W_star
count[3]<-count[3]+1
}
}
if (length(dim(X.curr)) <2){
X.curr <- matrix(X.curr,ncol=1)
}
## Gibbs steps
lam[i]<-rgamma(1,h1+nbasis[i],h2+1) # update lambda
S<-pd.solve(crossprod(X.curr)/s2[i-1]+diag(nbasis[i]+1)/tau2) # covariance matrix for beta update
beta[i,1:(nbasis[i]+1)]<-rmnorm(1,S%*%t(X.curr)%*%y/s2[i-1],S) # update beta
s2[i]<-1/rgamma(1,n/2+g1,rate=g2+.5*sum((y-X.curr%*%beta[i,1:(nbasis[i]+1)])^2)) # update s2
}
return(list(X=X.curr,rotation_mat=rotation_mat,b=bhat,count=count,knots=knots,signs=signs,vars=vars,nint=nint,nbasis=nbasis,beta=beta,s2=s2,lam=lam))
}
predict.bass<-function(mod,X,nburn=1000){ # prediction function, gets a prediction for each MCMC iteration
nmcmc<-length(mod$nbasis)
pred<-matrix(nrow=nmcmc-nburn,ncol=nrow(X))
for(i in (nburn+1):nmcmc){
B<-matrix(nrow=nrow(X),ncol=mod$nbasis[i]+1)
B[,1]<-1
for(j in 1:mod$nbasis[i]){
tmptmptmp <- mod$rotation_mat[i,j,1:mod$nint[i,j],]
if (is.null(dim(tmptmptmp))){
tmptmptmp <- matrix(tmptmptmp,nrow=1)
}
X_star_rot <- t(X %*% t(tmptmptmp))
B[,j+1]<-makeBasis(mod$signs[i,j,1:mod$nint[i,j]],mod$vars[i,j,1:mod$nint[i,j]],mod$knots[i,j,1:mod$nint[i,j]],X_star_rot)
}
pred[i-nburn,]<-B%*%mod$beta[i,1:(mod$nbasis[i]+1)]
}
return(pred)
}
################################################################################################################
# test it out
#set.seed(46)
f <-function(x){ # the Friedman function
10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
#apply(x,1,borehole,scale01=T)
}
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y)
mod$count
plot(mod$nbasis,type='l')
plot(y,mod$X%*%mod$b); abline(a=0,b=1,col=2) # X and b are from the last MCMC iteration
plot(mod$s2[-c(1:1000)],type='l')
plot(mod$lam[-c(1:1000)],type='l')
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
mean(((colMeans(pred))-f(xtest))**2)
mod2 <- BASS::bass(x, y)
mean(((colMeans(pred))-f(xtest))**2)
pred2 <- predict(mod2, xtest)
dim(x)
dim(xtest)
pred2 <- predict(mod2, xtest)
pred2 <- BASS::predict(mod2, xtest)
pred2 <- BASS:::predict(mod2, xtest)
pred2 <- BASS:::predict.bass(mod2, xtest)
pred2
plot(f(xtest), colMeans(pred2))
mean(((colMeans(pred2))-f(xtest))**2)
mean(((colMeans(pred))-f(xtest))**2)
nu_vec <- c(0.05, 0.1, 0.2, 0.5, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y)
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
nu_vec <- c(0.05, 0.1, 0.2, 0.5, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
MSE
rowMeans(MSE)
plot(nu_vec, rowMeans(MSE))
plot(nu_vec, rowMeans(MSE))
length(nu_vec)
foo <- rep(NA, 3)
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
#mod<-bass(x,y, nu_birth=nu_vec[i])
mod<-bass(x,y, nu_birth=0.75)
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
#plot(f(xtest),colMeans(pred)); abline(a=0,b=1,col=2)
foo[j] <- mean(((colMeans(pred))-f(xtest))**2)
#MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
mean(foo)
points(0.75, mean(foo))
mean(foo)
nu_vec <- c(0.05, 0.5, 0.5, 0.75 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
nu_vec <- c(0.05, 0.5, 0.5, 0.75, 1)
MSE <- matrix(NA, nrow=length(nu_vec), ncol=3)
for(i in seq_along(nu_vec)){
for(j in 1:3){
p <- 8
sigma <- .011 # noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*p),n,p) #10 variables, only first 5 matter
y <- rnorm(n,f(x),sigma)
mod<-bass(x,y, nu_birth=nu_vec[i])
xtest<-matrix(runif(1000*p),1000,p)
pred<-predict.bass(mod,xtest)
MSE[i,j] <- mean(((colMeans(pred))-f(xtest))**2)
}
}
plot(nu_vec, rowMeans(MSE))
MSE
tmp_y <- rowMeans(MSE)
abline(h=0.098)
abline(h=0.092)
abline(h=0.082)
abline(h=0.077)
tmp_y <- c(tmp_y, c(0.99, 0.92, 0.82, 0.78, 0.83))
tmp_y
tmp_x <- c(nu_vec, c(0.05, 0.1, 0.2, 0.5, 1))
plot(tmp_x, tmp_y)
tmp_y <- rowMeans(MSE)
tmp_y <- c(tmp_y, c(0.099, 0.092, 0.082, 0.078, 0.083))
plot(tmp_x, tmp_y)
lm(I(log(tmp_y))~tmp_x)
lm(tmp_y ~ I(tmp_x^2))
curve(0.0879 + 0.00312*x^2)
plot(tmp_x, tmp_y)
curve(0.0879 + 0.00312*x^2, add=TRUE)
mean(((colMeans(pred2))-f(xtest))**2)
pred2 <- BASS:::predict.bass(mod2, xtest)
mean(((colMeans(pred2))-f(xtest))**2)
abline(h=0.0012)
library(devtools)
document()
?tr
