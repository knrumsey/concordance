# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=pp, ncol=pp)
Ctrue[1:2, 1:2] <- matrix(c(8/3, 10/9, 10/9, 21/45), nrow=2, byrow=TRUE)
Ctrue[1:2, 1:2] <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Generate Data
X <- maximinLHS(N-2, pp)
X <- rbind(X, rep(0, pp))
X <- rbind(X, rep(1, pp))
Yf <- apply(X, 1, f)
p <- p_vec[i]
i=1
# Generate Data
X <- maximinLHS(N-2, pp)
X <- rbind(X, rep(0, pp))
X <- rbind(X, rep(1, pp))
Yf <- apply(X, 1, f)
p <- p_vec[i]
# activegp method
t0 <- Sys.time()
mod_gp <- mleHomGP(X[,1:p], Yf)
tgp1 <- Sys.time() - t0
Cgp = C_GP(mod_gp)
tgp2 <- Sys.time() - t0
# BASS method
t0 <- Sys.time()
mod_bass <- bass(X[,1:p], Yf, verbose=FALSE, temp.ladder=1.1^(0:5))
tbass1 <- Sys.time() - t0
Cbass = C_bass(mod_bass)
Cbass
ncol(1:5)
ncol(1:5) < 2
cbind(1:5, 1:4)
cbind(1:5, 1:5)
as.matrix(1:5)
tmp <- as.matrix(1:5)
cbind(tmp, tmp)
document()
devtools::document()
library(concordance)
matrix(0, 1, 1)
?match
mod
mod = mod[[1]]
document()
devtools::document()
C_bass
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 1000
p <- 3
# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=p, ncol=p)
Ctrue[1:2, 1:2] <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
X <- matrix(runif((N-2) * p), nrow=N-2, ncol=p)
Yf <- apply(X, 1, f)
mod_bass <- BASS::bass(X, Yf, verbose=FALSE)
Cbass <- C_bass(mod_bass)
length(mod_bass$nbasis)
tcrossprod(1)
document()
devtools::document()
Cbass <- C_bass(mod_bass)
162/54
devtools::document()
Cbass <- C_bass(mod_bass)
document()
devtools::document()
d1 <- sum(abs(Cbass - Ctrue))
d1
Cbass <- C_bass(mod_bass)
document()
library(devtools)
document()
Cbass <- C_bass(mod_bass)
mod = mod_bass
dim(mod$vars.des)
mod$nbasis
class(indic)
class(mod$vars.des[1,1:10,])
class(mod$vars.des[1,1:1,])
foo = (mod$vars.des[1,1:1,])
foo
dim(mod$vars.des)
dim(mod$vars.des[1,1:10])
dim(mod$vars.des[1,1:10,])
matrix(foo, nrow=1, ncol=length(foo))
document()
Cbass <- C_bass(mod_bass)
X <- lhs::maximinLHS(10, 2)
y <- X[,1]
mod <- bass(X, y)
mod <- BASS::bass(X, y)
C_bass(mod)
document()
library(concordance)
cbind(1:2, 2:3)
as.matrix(cbind(1:2, 2:3))
as.matrix(cbind(1, 1))
devtools::document()
library(concordance)
library(concordance)
Cfg_bass
?C1_bass
?C_bass
Cfg_bass
?Cfg_bass
?C_bass
as.matrix(1:5)
C_bass(mod1)
C_bass(mod)
C = C_bass(mod)
C[[1]]
E1 <- eigen(C1i)
E2 <- eigen(C2i)
E12 <- eigen(C12i)
C1i <- C1
C2i <- C2
C12i <- C12
f <- function(x) x[1]*x[2]
g <- function(x) x[1]^2 + x[2]
X <- lhs::maximinLHS(100, 2)
y1 <- apply(X,1,f)
y2 <- apply(X,1,g)
mod1 <- BASS::bass(X, y1)
mod2 <- BASS::bass(X, y2)
C1 <- C_bass(mod1)
C2 <- C_bass(mod2)
C12 <- Cfg_bass(mod1, mod2)
C1i <- C1
C2i <- C2
C12i <- C12
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity <- contrib <- list()
i
i = 1
V12[[i]] <- (C12[[i]] + t(C12[[i]]))/2
t1[[i]] <- sum(diag(C1i))
t2[[i]] <- sum(diag(C2i))
t12[[i]] <- sum(diag(C12i))
conc[[i]] <- t12[[i]]/sqrt(t1[[i]]*t2[[i]])
E1 <- eigen(C1i)
E2 <- eigen(C2i)
E12 <- eigen(C12i)
act_scores()
?act_scores()
act_scores
E1
V12
unlist(V12)
C12
V12[[i]] <- (C12[[i]] + t(C12[[i]]))/2
V12
C12
t(C12)
V12[[i]] <- (C12i + t(C12i))/2
V12
unlist(V12)
?print
unlist(1)
document()
library(concordance)
coactive_BASS(mod1, mod2)
mod1
coactive_BASS(mod1, mod2)
#'
#' @param mod1 BASS model representing function 1
#' @param mod2 BASS model representing function 2
#' @param prior NULL (default) Uniform(0,1) prior for each variable. See details fr required prior structure.
#' @param mcmc.use a vector of mcmc replications to use. Can also be a 2-column matrix with indices for f1 and f2.
#' @param q order for the activity score measures
#' @param ... additional arguments passed fd_grad()
#' @return Estimates of C1, C2, C12, V12, conc(f1, f2), contributions and coactivity scores
#' @details `measure` should be an argument-free function which simulates a draw x ~ p(x) where p is the prior measure. If `measure` is numeric, then Monte Carlo draws are simulated from the standard uniform distribution as `runif(measure[1])`.
#' @export
coactive_BASS <- function(mod1, mod2, prior=NULL, mcmc.use=NULL, q=1, ...){
if(is.null(mcmc.use)) mcmc.use <- min(length(mod1$s2), length(mod2$s2))
mcmc.use <- as.matrix(mcmc.use)
obj <- list
obj$C1 <- C_bass(mod1, prior, mcmc.use)
obj$C2 <- C_bass(mod2, prior, mcmc.use)
obj$C12 <- Cfg_bass(mod1, mod2, prior, mcmc.use)
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity <- contrib <- list()
nn <- nrow(mcmc.use)
for(i in 1:nn){
if(nn == 1){
C1i <- C1
C2i <- C2
C12i <- C12
}else{
C1i <- C1[[i]]
C2i <- C2[[i]]
C12i <- C12[[i]]
}
V12[[i]] <- (C12i + t(C12i))/2
t1[[i]] <- sum(diag(C1i))
t2[[i]] <- sum(diag(C2i))
t12[[i]] <- sum(diag(C12i))
conc[[i]] <- t12[[i]]/sqrt(t1[[i]]*t2[[i]])
activity1[[i]] <- act_scores(C1i, q)
activity2[[i]] <- act_scores(C12, q)
coactivity_signed[[i]] <- coact_scores(C12, q=q, type="signed")
coactivity_unsigned[[i]] <- coact_scores(C12, q=q, type="unsigned")
contrib[[i]] <- diag(C12i)/sqrt(t1[[i]]*t2[[i]])
}
if(nn == 1){
V12 <- V12[[1]]
t1 <- t1[[1]]
t2 <- t2[[1]]
t12 <- t12[[1]]
conc <- conc[[1]]
contrib <- contrib[[1]]
activity1 <- activity1[[1]]
activity2 <- activity2[[1]]
coactivity_signed <- coactivity_signed[[1]]
coactivity_unsigned <- coactivity_unsigned[[1]]
}
obj$V12 <- V12
obj$t1 <- t1
obj$t2 <- t2
obj$t12 <- t12
obj$conc <- conc
obj$contrib <- contrib
obj$activity1 <- activity1
obj$activity2 <- activity2
obj$coactivity_signed <- obj$coactivity_signed
obj$coactivity_unsigned <- obj$coactivity_unsigned
class(obj) <- "CoactiveSubspace"
return(obj)
}
document()
rm(coactive_BASS())
document()
View(coactive_BASS)
rm(coactive_BASS)
document()
coactive_BASS(mod1, mod2)
document()
coactive_BASS(mod1, mod2)
eig <- eigen(C)
W <- eig$vectors
lam <- eig$values
lam
V = V12
V
V = V12[[1]]
V
eig <- eigen(V)
W <- eig$vectors
lam <- eig$values
lam
order(lam)
order(lam, rev=TRUE)
rev(order(lam))
foo = round(rnorm(10, 10))
foo
foo = round(rnorm(10, 0, 10))
foo
sort()
sort(foo)
foo = rev(sort(foo))
foo
rev(order(foo))
rev(order(abs(foo)))
document()
coactive_BASS(mod1, mod2)
document()
coactive_BASS(mod1, mod2)
coact_scores(V, signed=TRUE)
coact_scores(V, signed=FALSE)
coact_scores(V, signed=FALSE, q=2)
coactive_BASS(mod1, mod2)
prior=NULL
mcmc.use=NULL
q=1
if(is.null(mcmc.use)) mcmc.use <- min(length(mod1$s2), length(mod2$s2))
mcmc.use <- as.matrix(mcmc.use)
obj <- list()
obj$C1 <- C_bass(mod1, prior, mcmc.use)
obj$C2 <- C_bass(mod2, prior, mcmc.use)
obj$C12 <- Cfg_bass(mod1, mod2, prior, mcmc.use)
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity <- contrib <- list()
nn <- nrow(mcmc.use)
for(i in 1:nn){
if(nn == 1){
C1i <- C1
C2i <- C2
C12i <- C12
}else{
C1i <- C1[[i]]
C2i <- C2[[i]]
C12i <- C12[[i]]
}
V12[[i]] <- (C12i + t(C12i))/2
t1[[i]] <- sum(diag(C1i))
t2[[i]] <- sum(diag(C2i))
t12[[i]] <- sum(diag(C12i))
conc[[i]] <- t12[[i]]/sqrt(t1[[i]]*t2[[i]])
activity1[[i]] <- act_scores(C1i, q)
activity2[[i]] <- act_scores(C12, q)
coactivity_signed[[i]] <- coact_scores(C12, q=q, signed=TRUE)
coactivity_unsigned[[i]] <- coact_scores(C12, q=q, signed=FALSE)
contrib[[i]] <- diag(C12i)/sqrt(t1[[i]]*t2[[i]])
}
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity_signed <- coactivity_unsigned <- contrib <- list()
nn <- nrow(mcmc.use)
for(i in 1:nn){
if(nn == 1){
C1i <- C1
C2i <- C2
C12i <- C12
}else{
C1i <- C1[[i]]
C2i <- C2[[i]]
C12i <- C12[[i]]
}
V12[[i]] <- (C12i + t(C12i))/2
t1[[i]] <- sum(diag(C1i))
t2[[i]] <- sum(diag(C2i))
t12[[i]] <- sum(diag(C12i))
conc[[i]] <- t12[[i]]/sqrt(t1[[i]]*t2[[i]])
activity1[[i]] <- act_scores(C1i, q)
activity2[[i]] <- act_scores(C12, q)
coactivity_signed[[i]] <- coact_scores(C12, q=q, signed=TRUE)
coactivity_unsigned[[i]] <- coact_scores(C12, q=q, signed=FALSE)
contrib[[i]] <- diag(C12i)/sqrt(t1[[i]]*t2[[i]])
}
if(nn == 1){
V12 <- V12[[1]]
t1 <- t1[[1]]
t2 <- t2[[1]]
t12 <- t12[[1]]
conc <- conc[[1]]
contrib <- contrib[[1]]
activity1 <- activity1[[1]]
activity2 <- activity2[[1]]
coactivity_signed <- coactivity_signed[[1]]
coactivity_unsigned <- coactivity_unsigned[[1]]
}
#'
#' @param mod1 BASS model representing function 1
#' @param mod2 BASS model representing function 2
#' @param prior NULL (default) Uniform(0,1) prior for each variable. See details fr required prior structure.
#' @param mcmc.use a vector of mcmc replications to use. Can also be a 2-column matrix with indices for f1 and f2.
#' @param q order for the activity score measures
#' @param ... additional arguments passed fd_grad()
#' @return Estimates of C1, C2, C12, V12, conc(f1, f2), contributions and coactivity scores
#' @details `measure` should be an argument-free function which simulates a draw x ~ p(x) where p is the prior measure. If `measure` is numeric, then Monte Carlo draws are simulated from the standard uniform distribution as `runif(measure[1])`.
#' @export
coactive_BASS <- function(mod1, mod2, prior=NULL, mcmc.use=NULL, q=1, ...){
if(is.null(mcmc.use)) mcmc.use <- min(length(mod1$s2), length(mod2$s2))
mcmc.use <- as.matrix(mcmc.use)
obj <- list()
obj$C1 <- C_bass(mod1, prior, mcmc.use)
obj$C2 <- C_bass(mod2, prior, mcmc.use)
obj$C12 <- Cfg_bass(mod1, mod2, prior, mcmc.use)
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity_signed <- coactivity_unsigned <- contrib <- list()
nn <- nrow(mcmc.use)
for(i in 1:nn){
if(nn == 1){
C1i <- C1
C2i <- C2
C12i <- C12
}else{
C1i <- C1[[i]]
C2i <- C2[[i]]
C12i <- C12[[i]]
}
V12[[i]] <- (C12i + t(C12i))/2
t1[[i]] <- sum(diag(C1i))
t2[[i]] <- sum(diag(C2i))
t12[[i]] <- sum(diag(C12i))
conc[[i]] <- t12[[i]]/sqrt(t1[[i]]*t2[[i]])
activity1[[i]] <- act_scores(C1i, q)
activity2[[i]] <- act_scores(C12, q)
coactivity_signed[[i]] <- coact_scores(C12, q=q, signed=TRUE)
coactivity_unsigned[[i]] <- coact_scores(C12, q=q, signed=FALSE)
contrib[[i]] <- diag(C12i)/sqrt(t1[[i]]*t2[[i]])
}
if(nn == 1){
V12 <- V12[[1]]
t1 <- t1[[1]]
t2 <- t2[[1]]
t12 <- t12[[1]]
conc <- conc[[1]]
contrib <- contrib[[1]]
activity1 <- activity1[[1]]
activity2 <- activity2[[1]]
coactivity_signed <- coactivity_signed[[1]]
coactivity_unsigned <- coactivity_unsigned[[1]]
}
obj$V12 <- V12
obj$t1 <- t1
obj$t2 <- t2
obj$t12 <- t12
obj$conc <- conc
obj$contrib <- contrib
obj$activity1 <- activity1
obj$activity2 <- activity2
obj$coactivity_signed <- obj$coactivity_signed
obj$coactivity_unsigned <- obj$coactivity_unsigned
class(obj) <- "CoactiveSubspace"
return(obj)
}
coactive_BASS(mod1, mod2)
document()
coactive_bass(mod1, mod2)
print(coactive_bass(mod1, mod2))
CoactiveSubspace.print <- function(x, ...){
cat("conc(f1, f2) = ", mean(unlist(x$conc)))
}
print(coactive_bass(mod1, mod2))
library(concordance)
min(length(mod1$s2), length(mod2$s2))
mcmc.use <- as.matrix(mcmc.use)
mcmc.use
if(ncol(mcmc.use) == 1)
cbind(mcmc.use, mcmc.use)
document()
library(concordance)
X <- lhs::maximinLHS(100, 6)
y <- apply(X, 1, duqling::friedman)
mod0 = bass(X, y)
mod0 = BASS::bass(X, y)
?friedman
?borehole
borehole(rep(0.5, 8)) == borehole(rep(0.5, 8, adjust_fidelity=1))
library(duqling)
borehole(rep(0.5, 8)) == borehole(rep(0.5, 8, adjust_fidelity=1))
borehole(rep(0.5, 8, adjust_fidelity=1))
borehole(rep(0.5, 8, adjust_fidelity=0.99))
borehole(rep(0.5, 8, adjust_fidelity=0))
borehole(rep(0.5, 8), adjust_fidelity=0)
borehole(rep(0.5, 8))
duqling::borehole(rep(0.5, 8))
duqling::borehole(rep(0.5, 8), scale01=TRUE)
duqling::borehole(rep(0.5, 8), scale01=TRUE) == duqling::borehole(rep(0.5, 8), scale01=TRUE, adjust_fidelity=1)
duqling::borehole(rep(0.5, 8), scale01=TRUE)
duqling::borehole(rep(0.5, 8), scale01=TRUE, adjust_fidelity=1)
y1 <- apply(X, 1, duqling::borehole, scale01=TRUE)
y2 <- apply(X, 1, duqling::borehole, scale01=TRUE, adjust_fidelity=1)
mod1 = bass(X, y1)
library(BASS)
mod1 = bass(X, y1)
library(BASS)
mod1 = bass(X, y1)
y1
dim(X)
X <- lhs::maximinLHS(200, 8)
y1 <- apply(X, 1, duqling::borehole, scale01=TRUE)
y2 <- apply(X, 1, duqling::borehole, scale01=TRUE, adjust_fidelity=1)
mod1 = bass(X, y1)
mod2 = bass(X, y2)
coactive_bass(mod1, mod2)
if(is.null(mcmc.use)) mcmc.use <- min(length(mod1$s2), length(mod2$s2))
mcmc.use <- as.matrix(mcmc.use)
if(ncol(mcmc.use)==1) mcmc.use <- cbind(mcmc.use, mcmc.use)
obj <- list()
obj$C1 <- C_bass(mod1, prior, mcmc.use[,1])
obj$C2 <- C_bass(mod2, prior, mcmc.use[,2])
obj$C12 <- Cfg_bass(mod1, mod2, prior, mcmc.use)
obj$C12
obj$C1
obj$C12
t(obj$C12)
V12 <- t1 <- t2 <- t12 <- conc <- activity1 <- activity2 <- coactivity_signed <- coactivity_unsigned <- contrib <- list()
nn <- nrow(mcmc.use)
nn
i = 1
if(nn == 1){
C1i <- C1
C2i <- C2
C12i <- C12
}else{
C1i <- C1[[i]]
C2i <- C2[[i]]
C12i <- C12[[i]]
}
(C12i + t(C12i))/2
C12i
coactive_bass(mod1, mod2)
document()
coactive_bass(mod1, mod2)
diag(C12)
eigen(V12)
V12
V
C = V
eigen(V)
C
C1 = C_bass(mod1)
C2 = C_bass(mod2)
C12 = Cfg_bass(mod1, mod2)
V12 = (C12 + t(C12))/2
V12
sum(diag(V12))
sum(eigen(V12)$values)
diag(C12)
eigen(V12)$values
document()
coactive_bass(mod1, mod2)
library(concordance)
CONC
dim(CONC)
document()
library(concordance)
document()
library(concordance)
choose(140, 2)
plot(mod)
plot(mod[[1]])
document()
