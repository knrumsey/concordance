mod <- mod_b
if(is.null(mcmc.use)){
mcmc.use <- length(mod$nbasis)
}
gbass_flag <- "gbass" %in% class(mod)
if(gbass_flag){
mod$knotInd.des <- mod$knots.des
}
# Parse the prior information
if(is.null(prior)){
prior <- list()
for(i in 1:mod$pdes){
prior[[i]] <- list(dist="uniform")
}
}
#HANDLE PRIORS
for(i in 1:(mod$pdes)){
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- BASS:::scale.range(prior[[i]]$trunc, mod$range.des[,i])
# 2. Handle ach distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- BASS:::scale.range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc # DF: prior[[i]]$z # change weights with truncation # divide by cc instead to keep the same prior shape# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.0005, 0.9995), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "uniform"){
prior[[i]]$weights = 1
#Check for extrapolation
if(((prior[[i]]$trunc[1] < 0 - 0.1) | (prior[[i]]$trunc[2] > 1 + 0.1))){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "beta"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01 | abs(max(mod$xx.des[,i]) - 1) > 0.01){
warning("For dist=\"beta\", data should be scaled to (0, 1) range BEFORE fitting bass model")
}
}
if(distribution == "gamma"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01){
warning("For dist=\"gamma\", data should be shifted to have a minimum of 0 BEFORE fitting bass model")
}
prior[[i]]$rate = prior[[i]]$rate * prior[[i]]$trunc[2]
}
}
prior = NULL
mcmc.use=NULL
scaled=FALSE
if(is.null(mcmc.use)){
mcmc.use <- length(mod$nbasis)
}
gbass_flag <- "gbass" %in% class(mod)
if(gbass_flag){
mod$knotInd.des <- mod$knots.des
}
# Parse the prior information
if(is.null(prior)){
prior <- list()
for(i in 1:mod$pdes){
prior[[i]] <- list(dist="uniform")
}
}
#HANDLE PRIORS
for(i in 1:(mod$pdes)){
# 1. Scale prior truncation bounds to BASS scale
if(is.null(prior[[i]]$trunc)){
prior[[i]]$trunc <- mod$range.des[,i]
}
prior[[i]]$trunc <- BASS:::scale.range(prior[[i]]$trunc, mod$range.des[,i])
# 2. Handle ach distribution type separately
distribution = prior[[i]]$dist
if(distribution == "normal"){
if(is.null(prior[[i]]$weights)){
num_mix <- length(prior[[i]]$mean)
prior[[i]]$weights <- rep(1/num_mix, num_mix)
}
prior[[i]]$mean <- BASS:::scale.range(prior[[i]]$mean, mod$range.des[,i])
prior[[i]]$sd <- prior[[i]]$sd/(mod$range.des[2,i] - mod$range.des[1,i])
prior[[i]]$z <- pnorm((prior[[i]]$trunc[2]-prior[[i]]$mean)/prior[[i]]$sd) - pnorm((prior[[i]]$trunc[1]-prior[[i]]$mean)/prior[[i]]$sd)
cc <- sum(prior[[i]]$weights*prior[[i]]$z)
prior[[i]]$weights <- prior[[i]]$weights/cc # DF: prior[[i]]$z # change weights with truncation # divide by cc instead to keep the same prior shape# does the truncation change the distribution shape in the non-truncated regions??
#Check for extrapolation
qq <- qnorm(c(0.0005, 0.9995), prior[[i]]$mean, prior[[i]]$sd)
if((qq[1] < 0 - 0.1) | (qq[2] > 1 + 0.1)){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "uniform"){
prior[[i]]$weights = 1
#Check for extrapolation
if(((prior[[i]]$trunc[1] < 0 - 0.1) | (prior[[i]]$trunc[2] > 1 + 0.1))){
warning('You are asking the emulator to extrapolate. This is not reccomended.')
}
}
if(distribution == "beta"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01 | abs(max(mod$xx.des[,i]) - 1) > 0.01){
warning("For dist=\"beta\", data should be scaled to (0, 1) range BEFORE fitting bass model")
}
}
if(distribution == "gamma"){
prior[[i]]$weights = 1
if(abs(min(mod$xx.des[,i]) - 0) > 0.01){
warning("For dist=\"gamma\", data should be shifted to have a minimum of 0 BEFORE fitting bass model")
}
prior[[i]]$rate = prior[[i]]$rate * prior[[i]]$trunc[2]
}
}
# Make constantine matrix
Cf_post <- list()
if(!gbass_flag){
Xt <- mod$xx.des
}
# Get transformation matrix
A_tform <- diag(1/apply(mod$range.des, 2, diff))
r=1
i=1
#Compute only the stuff we will need for every iteration
rr <- mcmc.use[r]
mod_number_new <- mod$model.lookup[rr]
coeff      <- mod$beta[rr,]
coeff      <- matrix(coeff[!is.na(coeff)][-1], nrow=1)
M_new <- length(coeff)
compute_flag <- FALSE
if(r == 1){
compute_flag <- TRUE
}else{
if(mod_number != mod_number_new){
compute_flag <- TRUE
}
}
mod_number <- mod_number_new
M          <- M_new
signs      <- mod$signs.des[mod_number, 1:M, ]
indic      <- mod$vars.des[mod_number, 1:M, ]
if(gbass_flag){
knots    <- mod$knots.des[mod_number, 1:M, ]
}else{
knots    <- mod$knotInd.des[mod_number, 1:M, ]
}
knots
gbass_flag
class(mod)
class(mod_g)
mod <- mod_g
class(mod_b)
mod_b <- gm2bm(mod)
mod_b
class(mod_b)
mod_b <- gm2bm(mod_g)
class(mod_g)
class(mod_b)
library(GBASS)
GBASS::gm2bm
detach("package:GBASS", unload = TRUE)
library(GBASS)
GBASS::gm2bm()
GBASS::gm2bm
mod
mod_b <- gm2bm(mod)
mod_g
mod <- gm2bm(mod_g)
class(mod)
sobol(mod)
sob <- sobol(mod)
C <- C_bass(mod)
C
foo = bass(X, y)
C_bass(foo)
plot(foo)
plot(mod)
plot(mod_g)
plot(foo)
C
class(mod)
C_bass(mod)
C_bass(foo)
matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(500, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
eigen(C)
document()
devtools::document()
C_bass
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y)
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y, t=20)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- tbass(X, y, df=100)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
t
knots
?gbass
mod_g <- nwbass2(X, y, df=100)
mod_g <- nwbass2(X, y)
?nwbass
mod_g <- nwbass(X, y)
nwbass2
library(GBASS)
library(BASS)
library(concordance)
library(activegp)
library(hetGP)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.46*(0.1))
mod_g <- nwbass(X, y)
#sob <- sobol(mod)
C <- C_bass(mod)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
mod_g <- tbass(X, y, df=200)
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
devtools::document()
#sob <- sobol(mod)
C <- C_bass(mod)
C
mod <- gm2bm(mod_g)
#sob <- sobol(mod)
C <- C_bass(mod)
C
#C_true
matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
X <- lhs::randomLHS(1000, 2)
y <- apply(X, 1, f) + rnorm(500, 0, 0.01)
y[1:5] <- y[1:5] + rnorm(0.5)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 1000
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:5] <- y[1:5] + rnorm(n, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 500
n_corrupted <- 5
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:n_corrupted] <- y[1:n_corrupted] + rnorm(n_corrupted, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
mod1 <- tbass(X, y, df=5)
mod1 <- gm2bm(mod1)
# Get C matrices
C0 <- C_bass(mod0)
C1 <- C_bass(mod1)
Ctrue <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Get error
D0 <- C0 - Ctrue
D1 <- C1 - Ctrue
sum(abs(D0))
sum(abs(D1))
#Print matrices
C0
C1
Ctrue
library(GBASS)
library(BASS)
library(concordance)
library(lhs)
set.seed(11111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 500
n_corrupted <- 5
p <- 2
X <- lhs::randomLHS(n, p)
y <- apply(X, 1, f) + rnorm(n, 0, 0.01)
y[1:n_corrupted] <- y[1:n_corrupted] + rnorm(n_corrupted, 0.5)
#Fit BASS and GBASS Models
mod0 <- bass(X, y)
mod1 <- tbass(X, y, df=5)
mod1 <- gm2bm(mod1)
# Get C matrices
C0 <- C_bass(mod0)
C1 <- C_bass(mod1)
Ctrue <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Get error
D0 <- C0 - Ctrue
D1 <- C1 - Ctrue
sum(abs(D0))
sum(abs(D1))
#Print matrices
C0
C1
Ctrue
D <- matrix(rnorm(25), nrow=5)
D%*%D
crossprod(D)
tcrossprod(D)
D%*%t(D)
devtools::document()
library(concordance)
install.packages("badger")
BASS:::scale.range
?BASS:::scale.range
?BASS::scale.range
?BASS:::scale.range
library(BASS)
?BASS:::scale.range
BASS:::scale_range()
BASS:::scale_range
document()
library(concordance)
library(BASS)
library(activegp)
library(hetGP)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=pp, ncol=pp)
Ctrue[1:2, 1:2] <- matrix(c(8/3, 10/9, 10/9, 21/45), nrow=2, byrow=TRUE)
Ctrue[1:2, 1:2] <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=pp, ncol=pp)
# Sim Study Parameters
N <- 100
p_vec <- c(2, 3, 4, 5, 10, 20, 50, 100)
pp <- max(p_vec)
# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=pp, ncol=pp)
Ctrue[1:2, 1:2] <- matrix(c(8/3, 10/9, 10/9, 21/45), nrow=2, byrow=TRUE)
Ctrue[1:2, 1:2] <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
p_vec
p = 2
mod_bass <- bass(X[,1:p], Yf, verbose=FALSE, temp.ladder=1.1^(0:5))
# Generate Data
X <- maximinLHS(N-2, pp)
X <- rbind(X, rep(0, pp))
X <- rbind(X, rep(1, pp))
Yf <- apply(X, 1, f)
mod_bass <- bass(X[,1:p], Yf, verbose=FALSE, temp.ladder=1.1^(0:5))
C_bass(mod_bass)
library(concordance)
library(devtools)
library(roxygen2)
document()
C_bass(mod_bass)
Ctrue
C_bass(mod_bass)
Ctrue[1:2,1:2]
library(devtools)
library(roxygen2)
build_vignettes("concordance")
build_vignettes()
library(concordance)
browseVignettes("concordance")
browseVignettes(concordance)
library(devtools)
build_vignettes()
browseVignettes("concordance")
?browseVignettes
browseVignettes()
document()
browseVignettes()
browseVignettes("concordance")
exp(-2)
exp(2)
library(concordance)
library(BASS)
library(activegp)
library(hetGP)
library(lhs)
set.seed(1111)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Sim Study Parameters
N <- 100
p_vec <- c(2, 3, 4, 5, 10, 20, 50, 100)
pp <- max(p_vec)
# Get true value of C matrix (analytically)
Ctrue <- matrix(0, nrow=pp, ncol=pp)
Ctrue[1:2, 1:2] <- matrix(c(8/3, 10/9, 10/9, 21/45), nrow=2, byrow=TRUE)
Ctrue[1:2, 1:2] <- matrix(1/45*c(120, 50, 50, 21), nrow=2, byrow=TRUE)
# Generate Data
X <- maximinLHS(N-2, pp)
X <- rbind(X, rep(0, pp))
X <- rbind(X, rep(1, pp))
Yf <- apply(X, 1, f)
p <- p_vec[i]
i=1
# Generate Data
X <- maximinLHS(N-2, pp)
X <- rbind(X, rep(0, pp))
X <- rbind(X, rep(1, pp))
Yf <- apply(X, 1, f)
p <- p_vec[i]
# activegp method
t0 <- Sys.time()
mod_gp <- mleHomGP(X[,1:p], Yf)
tgp1 <- Sys.time() - t0
Cgp = C_GP(mod_gp)
tgp2 <- Sys.time() - t0
# BASS method
t0 <- Sys.time()
mod_bass <- bass(X[,1:p], Yf, verbose=FALSE, temp.ladder=1.1^(0:5))
tbass1 <- Sys.time() - t0
Cbass = C_bass(mod_bass)
Cbass
ncol(1:5)
ncol(1:5) < 2
cbind(1:5, 1:4)
cbind(1:5, 1:5)
as.matrix(1:5)
tmp <- as.matrix(1:5)
cbind(tmp, tmp)
document()
devtools::document()
library(concordance)
